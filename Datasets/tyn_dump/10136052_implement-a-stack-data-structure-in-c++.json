{
    "title": "How to Implement a Stack Data Structure in C++",
    "url": "https://www.wikihow.com/Implement-a-Stack-Data-Structure-in-C%2B%2B",
    "category_hierarchy": [
        "Computers and Electronics",
        "Software",
        "Programming"
    ],
    "parts": [
        {
            "name": "Configuring the Initial Environment",
            "steps": [
                {
                    "headline": "Open your IDE (Integrated Development Environment).",
                    "description": "If you are using Visual Studio, you can open it by pressing the Windows Key and then searching for \"Visual Studio\". An IDE is required to run your program. If you do not have an IDE installed, install one prior to continuing with this article. Though no particular IDE is required, the initial environment configuration steps in this project will be demonstrated in Visual Studio. If you are already familiar with configuring an environment and creating a class, then do so and proceed to part two, where you will begin implementing the stack class. You can use How to Install Visual Studio (Windows) or How to Install and Configure Xcode (Mac OS X) to help with installation."
                },
                {
                    "headline": "Create a new project.",
                    "description": "You must create a new project to group all the code that is associated with the specific goal you are trying to achieve. This helps with organization as sometimes the specific goal you are trying to achieve may require a substantial amount of code. In Visual Studio, use the keyboard shortcut Ctrl+\u21e7 Shift+N to open a new project.. In the rare case your Project does not open to a CLR Project (Clear Project), create a new C++ CLR Project by clicking on:\nInstalled (Side Panel)\nVisual C++ (Side Panel)\nCLR (Side Panel)\nCLR Empty Project (Center view)"
                },
                {
                    "headline": "Enter the details for your project.",
                    "description": "At the bottom of your New Project window, there will three text boxes: Name, Location, Solution Name. Though it is not required, you probably want to fill them to help decipher between other projects. After you have entered these, click the \"OK\" button at the bottom right. Name: stackType <Something Indicative of the Project>\nLocation: Browse for your Documents folder <Anywhere you can access easily>\nSolution Name: stackType <Something Indicative of this specific module>"
                },
                {
                    "headline": "Add a class to your project.",
                    "description": "In Visual Studio, the easiest way to add class is to simply use the keyboard shortcut Ctrl+\u21e7 Shift+X. Once the window title Class Wizard opens, click the Add Class button towards the top right."
                },
                {
                    "headline": "Enter the details for your class.",
                    "description": "In the Add Class window, enter StackLinked in the text box titled Class Name. Assure that none of the option boxes towards the bottom are checked. Once this is completed, click the OK button towards the bottom right."
                }
            ]
        },
        {
            "name": "Preparing Your Pre-Implementation Files",
            "steps": [
                {
                    "headline": "Implement the StackLinked Class Header using the code given below.",
                    "description": "In order to implement the methods needed, you must first let the IDE know the names of those methods. To do this, simply copy the code in the box below to your StackLinked.h file. A stack can have many implementations which range in complexity; however, here you will be implementing the most fundamental and most well-known version, which will consist of isEmpty, push, and pop. In Visual Studio, once you have coded the signatures in StackLinked.h, it will likely show you an error until you code the definitions in the StackLinked.cpp file; there is no need to worry as you will do just this in the coming steps. #include <stdexcept>\nusing namespace std;\n\ntemplate <typename DataType>\nclass StackLinked {\n  public:\n    StackLinked( );    // Constructor\n    ~StackLinked( );  // Destructor\n\n    // Member functions\n    void push( const DataType& newDataItem );\n    DataType pop( ) throw ( logic_error );\n    bool isEmpty( ) const;\n\n    // Display Stack (Testing and Debugging)\n    void showStructure() const;\n\n  private:\n   /* \n    *                             !!!!! NOTE  !!!!! :  \n    *  LEAVE ROOM HERE TO INSERT --- Node Class --- IN THE NEXT STEP >\n    */\nStackNode* top;  // Ptr to remember top of stack\n};"
                },
                {
                    "headline": "Implement StackNode in the StackLinked Class.",
                    "description": "Since this stack implementation utilizes a Linked List, which is just a chain of connected boxes (nodes) containing data, you will need to include the StackNode class. To do this, again, simply copy paste the code from below to your StackLinked.h file. This will allow the implementation to make the boxes and connect them together. It is crucial that you do this step carefully, for if this is not done correctly then nothing else will work. Furthermore, if done incorrectly, this may result in memory leak; which will not be good for you computer. You can think of this as the basic building block for your stack. // Node Class (Each item in stack is one node, insert this in the same file as above)\nclass StackNode {\n    public:\n        StackNode(const DataType& nodeData, StackNode* nextPtr) {\n            dataItem = nodeData;\n            next = nextPtr;\n        }\n\n    DataType dataItem;  // Data stored in node\n    StackNode* next;     // Pointer holding the address of the next node\n};"
                }
            ]
        },
        {
            "name": "Implementing the Code for Stack",
            "steps": [
                {
                    "headline": "Implement the Constructor.",
                    "description": "To implement this, initialize the top pointer to nullptr. This is telling the computer that, for now, don't point to any memory address in specific, but be ready to shortly. This is require because, logically, it is impossible to use something that isn't built. Ensure to include comments in your code to help you better understand. The run time complexity of this is O(1). /* \n* Default Constructor\n* Method to initialize all class variables\n* PreCondition - None\n* PostCondition - top is initialized\n*/\n// Class Member top is initialized to nullptr\ntemplate <typename DataType>\nStackLinked<DataType>::StackLinked ( ) {\n    top = nullptr;  // initialize value\n}"
                },
                {
                    "headline": "Implement the Destructor.",
                    "description": "The destructor will deallocate all the nodes in the stack. To deallocate a node: \n First, reference the top node with a temporary node (to remember the location). Second, move the top node to the next (previous) item. Think of this like a stack of boxes, to reduce the size, you take one box off at a time. Lastly, deallocate the memory taken by the previous node with the temporary node created. Repeat this process until the stack is empty to destruct entire stack  \nSince the nodes dynamically allocate memory, which means they ask the computer for space to put their data, they must be deallocated when no longer needed. If the class does not have a destructor, then it will lead to memory leak. The complexity of this method is O(n). /*\n* Destructor\n* Method will deallocate all space taken by the stack\n* PreCondition - None ( No operations preformed is stack if empty )\n* PostCondition - top = nullptr ( No Nodes in Stack )\n*/\n// All nodes in stack are deallocated \ntemplate <typename DataType>\nStackLinked<DataType>::~StackLinked( ) {\n    StackNode* traverse; // Temp NodePtr\n    \n    while ( !this->empty( ) ) { // Stop when no nodes left\n        traverse = top;        // Remember the previous top node\n        top = top->next; // Move top node to the next node\n        delete traverse;       // Deallocate the top node stored at start \n    }\n}\n \n\n Implement the push. The push method adds a data item to the top of the stack. In layman's terms, it will add another \"box of data\" on top of the existing \"boxes of data\". In order to do this, you ask the computer for more space, put whatever data you want in there, then connect the last \"box of data\" to your new \"box of data\". Think of this either like stacking boxes, or adding train cars on to a train. In order to add a train car, you first have to get a train car and fill it with things, then link the old train car to your new one. The complexity of this method is O(1). // Method to insert an item at the top of the stack\n// \tnewDataItem: Data item that will be inserted on top of stack\ntemplate <typename DataType>\nvoid StackLinked<DataType>::push( const DataType& newDataItem ) {\n    // Allocate new node with newDataItem and link to previous top\n    StackNode* t = new StackNode ( newDataItem, top ); \n    top = t;\t\t   // Insert item to top of stack\n}\n \n \n Implement the pop. The functionality of pop is to remove the top item of the stack. Since you are using a linked list (connected boxes), be very careful to make sure you are deallocating the memory correctly. First, store the data in the top node so you can return it to the user. Second, create a new node that is referencing the memory location of the top node. Third, reduce the size of the stack by moving the top node to the next item (your new top ). Lastly, you must delete the node being referenced by the temporary node you have created and return the data item that was stored at the position. Referring back to the train analogy, you want to take all things out of your train car, tell someone to hold it so it doesn't roll away when you remove it, unlink it from the next train car, and then destroy it because you don't need it any more. The complexity of this method is O(1). // Method will remove the top member of the stack \n// (most recently inserted) and return that data (PostCondition)\n// \tFunction will throw Stack is not empty\ntemplate <typename DataType>\nDataType StackLinked<DataType>::pop() throw (logic_error) {\n\tif ( !this->empty( ) ) {\n\t\tDataType d = top->dataItem;  // Hold data at the top of stack\n\t\tStackNode* t = top;\t\t\t// Temp. store address of top\n\t\ttop = top->next;\t\t\t// Advance top to now reference next item\n\t\tdelete t;\t\t\t\t\t// Deallocate the space being used by previous top\n\t\treturn d;\t\t\t\t\t// Return data stored in the previous top node\n\t} else {  \t// PreCondition is that the stack cannot be empty\n\t\tthrow  logic_error(\"Error: Pop was unsuccessful. Make sure stack is not empty. \");\n\t}\n}\n \n  \n Implement isEmpty. The functionality of isEmpty is exactly as you would expect: it will simply determine if there are any items in the stack. To do this, you can simply check if the top node is referencing anything. If it is, then you know that it is not empty because there is data there; otherwise you know that it is empty because it doesn't have any space to hold anything. You can do this because you know that the top will hold the most recent item; therefore if the most recent item is nothing this implies that there in nothing before it. Again referring to the train analogy, if you want to know a train is empty, then you just check if the train engine car is linked to or contains anything. As for the boxes analogy, you just check if there's a box; if there is not, then there is nothing. The complexity of this method is O(1). // Will determine if list is empty ( No space taken by stack )\n// PreCondition: None\n// PostCondition: Return either true or false\ntemplate <typename DataType>\nbool StackLinked<DataType>:: isEmpty( ) const {\n\treturn ( top == nullptr );\n}"
                }
            ]
        },
        {
            "name": "Testing the Implementation",
            "steps": [
                {
                    "headline": "Add a new file to your project.",
                    "description": "Now that the stack has been implemented, validate the implementation behavior. To do this, create a testStack.cpp file by using the keyboard short cut Ctrl+N and renaming the file testStack.cpp. Alternatively, right click the source folder and select Add new item, rename this item testStack.cpp."
                },
                {
                    "headline": "Add the following code in the test file.",
                    "description": "Insert the code below in the testStack.cpp file created in the last step. This code will test all the functions you have implemented. Make sure to read the project description, which outlines the specifications and test cases. Needless to say, testing implementations is very important, because if you coded something that doesn't work, then there wasn't really any purpose in doing it. More importantly, when working with dynamic allocation should not produce any memory leaks, stack overflows, etc. ///////////////////// -- PROJECT DESCRIPTION -- ////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  \n//  Testing File for Stack Data Structure\n//  \n//  SPECIFICATIONS:\n//  \n//  \tPush:  \n//  \t\tShould add item to top of stack\n//\n//  \tPop:   \n//  \t\tShould remove item from top of stack\n//  \t\t\n//\tEmpty: \n//\t\tShould say \"empty stack\" if no items otherwise \n//\t\tsay \"not empty stack\"\n//\t\t\t\n//\toperator= :\n//\t\tShould make a copy of a stack (right hand side) \n//\t\tin other stack (left hand side)\n//\n//\tStack<DataType> exampleStack: \n//\t\tShould make a empty stack\n//\t\t\n//\tStack<DataType> temp(oldStack): \n//\t\tShould copy items from oldstack and put them in temp\n//\t\tstack\n//\t\t\t\n//\tTEST CASES:\n//\t\n//\t\tSTEP NO. |\tCOMMAND   |   RESULT\n// \t\t------------------------------------------------------\n//\t\t   1\t          |  +a+b+c\t      |   [c] b a\n//\t\t   2\t          |  --\t  \t              |   [a]\n//\t\t   3\t          |  E\t\t              |   Stack is NOT empty\n//\t\t   4\t          |  +e\t \t      |   [e] a\n//\t\t   5\t          |  C\t\t      |\t  Stack is empty\n//\t\t   6\t          |  Q\t\t      |\t  N/A\n//\t\t   \n//\tPASS CRITERIA FOR IMPLEMENTATION:\n//\t\t- All Test Cases above produce proper result\n//\t\t- All Stack specifications are followed\n//\t\t- No Memory Leaks, Build Errors, Segmentation Faults, etc. //\t\t\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////  Header Files and Namespaces - DO NOT DELETE ////////////////////////\n#include <iostream>\t\t// For cout <<\n#include <iomanip>\t\t\t// For formatted output\n#include \"StackLinked.cpp\"\t// To use your stack implementation\nusing namespace std;\t\t// Use items in std namespace (std::)\n////////////  Header Files and Namespaces - DO NOT DELETE ////////////////////////\n\n//////////// SHOW STRUCTURE - TESTING AND DEBUGGING //////////////////////\n/*\n* Outputs the data items in a stack. * If the stack is empty, outputs \"Empty stack\". */\ntemplate <typename DataType>\nvoid StackLinked<DataType>::showStructure() const {\n    if( isEmpty() ) {\n\tcout << \"Empty stack\" << endl;\n    } else {\n        cout << \"Top\\t\";\n\tfor (StackNode* temp = top; temp != 0; temp = temp->next) {\n\t    if( temp == top ) {\n\t\tcout << \"[\" << temp->dataItem << \"]\\t\";\n\t    } else {\n\t\tcout << temp->dataItem << \"\\t\";\n\t    }\n\t}\n        cout << \"Bottom\" << endl;\n    }\n}\n//////////// SHOW STRUCTURE - TESTING AND DEBUGGING //////////////////////\n\n////////////  TESTING MENU - START ///////////////////////////\nvoid testMenu( ) {\n    cout << setw( 20 ) << left << \"Command\"\n    \t << setw( 20 ) << left << \"Description\" << endl;\n    cout << setw( 20 ) << left << \"H\"\n    \t << setw( 20 ) << left << \"Show Help Menu.\" << endl;\n    cout << setw( 20 ) << left << \"+[item]\"\n    \t << setw( 20 ) << left << \"Push item ([item]) to stack. '[item]' is a placeholder. (ex. +a will add 'a' to stack.)\" << endl;\n    cout << setw( 20 ) << left << \"-\"\n    \t << setw( 20 ) << left << \"Pop item from stack. Will remove last inserted item to stack.\" << endl;\n    cout << setw( 20 ) << left << \"E\"\n    \t << setw( 20 ) << left << \"Check if stack is empty\" << endl;\n    cout << setw( 20 ) << left << \"Q\"\n    \t << setw( 20 ) << left << \"Terminate testing.\" << endl << endl;\n}\n////////////  TESTING MENU - END  ///////////////////////////////\n\nint main() {\n    cout << \"Testing Stack Data Structure Implementation\" << endl;\n    cout << \"-----------------------------------------------------------\" << endl;\n    \n    StackLinked<char> testStack;  // Stack\n    char testDataItem, cmd; \t      // Stack data item, Input Command\n    testMenu();\t\t\t              // Show Command Menu\n\n    // TESTING LOOP (READ CMD -> PREFORM OPERATION)\n    do {\n        testStack.showStructure();                              // Output stack\n        cout << endl << \"Command: \";  cin >> cmd;\t// Read command\n        \n\ttry {\n\t    switch ( cmd ) {\n\t      case 'H' : case 'h': testMenu(); break;\n\t      case '+' : cin >> testDataItem; testStack.push(testDataItem); break;\n\t      case '-' : cout << \"Popped \" << testStack.pop() << endl; break;\n\t      case 'Q' : case 'q' : break;\n\t      case 'E' : case 'e' : cout << ( ( testStack.isEmpty() ) ? ( \"Stack is empty\\n\" ) : \n\t      \t\t( \"Stack is NOT empty\\n\") ); break;\n\t      default : cout << cmd << \"is an invalid command. Enter H to see menu.\" << endl;\n             }\n          } catch ( logic_error _stackError ) {\n\t      cout << \"ERROR: \" << _stackError.what() << endl;\n\t  }\n    } while ( cin && cmd != 'Q' && cmd != 'q' );\n}"
                },
                {
                    "headline": "Run tests.",
                    "description": "Sometimes when implementing functions, you will run in to errors; however there is no need to worry. This simply means that, either you told the computer to do something other than what you intended or the computer simply doesn't understand what you are telling it to do. Common bugs faced when implementing a stack include: \n Not incrementing your top node member which results in each push simply overwriting the previous item \n Not correctly deallocating a node in the pop and destructor methods which results in the computer showing memory leak or \"segmentation fault\" errors. Naturally, it is nearly impossible to outline the solution for every problem that could occur here; however having a solid approach to debugging methods is often a universal solution. See how to develop this approach below, even if you did not face any errors in your implementation."
                }
            ]
        },
        {
            "name": "Debugging",
            "steps": [
                {
                    "headline": "Walk through the particular function or program that has an issue.",
                    "description": "Visualize what each line of code is doing. This will help with targeting the issue."
                },
                {
                    "headline": "Comment and clean up your code and identifiers.",
                    "description": "This will help both you and others read the code and identify where a particular function isn't working according to specification."
                },
                {
                    "headline": "Research the gaps in your understanding.",
                    "description": "If you are not completely sure what a particular function, operator, or generally any line in your code is doing, then break it down to find what exactly you aren't able to piece together and search it on the internet. It is highly likely you are not the first person to have that question. In doing this, do not simply solve the problem, understand why it occurred so you become less likely to do it in the future. When the code gets more complex and the number of errors is not decreasing, this will cause increasing frustration."
                },
                {
                    "headline": "Ask a friend or colleague to also take a look at your code.",
                    "description": "It is possibly that you are skipping over some detail that a new set eyes may be able to see. However, your code must be well formatted so they can understand, further implicating the importance of following coding conventions."
                },
                {
                    "headline": "Step back and take a break from the code.",
                    "description": "Attempt to mentally run through how the code should be working, possibly think of a better way to do the same function, or just don't think about the whole program at all to refresh your thinking. Once you have found a possibly solution or have relaxed your mind, get back and attempt to solve it again. More often than not, you will be able to see the mistake being made."
                },
                {
                    "headline": "Set breakpoints at lines where you think the program is failing.",
                    "description": "If you are utilizing an IDE, then you can set breakpoints at specific lines of code; this will tell the computer to stop running for a moment so that you can see exactly what it has already done and predicate what it will do next. This will often show you exactly why the program is failing to execute how you want it."
                }
            ]
        }
    ],
    "tyn": [
        "Any C++ IDE"
    ],
    "text": " Configuring the Initial Environment Open your IDE (Integrated Development Environment). If you are using Visual Studio, you can open it by pressing the Windows Key and then searching for \"Visual Studio\". An IDE is required to run your program. If you do not have an IDE installed, install one prior to continuing with this article. Though no particular IDE is required, the initial environment configuration steps in this project will be demonstrated in Visual Studio. If you are already familiar with configuring an environment and creating a class, then do so and proceed to part two, where you will begin implementing the stack class. You can use How to Install Visual Studio (Windows) or How to Install and Configure Xcode (Mac OS X) to help with installation. Create a new project. You must create a new project to group all the code that is associated with the specific goal you are trying to achieve. This helps with organization as sometimes the specific goal you are trying to achieve may require a substantial amount of code. In Visual Studio, use the keyboard shortcut Ctrl+\u21e7 Shift+N to open a new project.. In the rare case your Project does not open to a CLR Project (Clear Project), create a new C++ CLR Project by clicking on:\nInstalled (Side Panel)\nVisual C++ (Side Panel)\nCLR (Side Panel)\nCLR Empty Project (Center view) Enter the details for your project. At the bottom of your New Project window, there will three text boxes: Name, Location, Solution Name. Though it is not required, you probably want to fill them to help decipher between other projects. After you have entered these, click the \"OK\" button at the bottom right. Name: stackType <Something Indicative of the Project>\nLocation: Browse for your Documents folder <Anywhere you can access easily>\nSolution Name: stackType <Something Indicative of this specific module> Add a class to your project. In Visual Studio, the easiest way to add class is to simply use the keyboard shortcut Ctrl+\u21e7 Shift+X. Once the window title Class Wizard opens, click the Add Class button towards the top right. Enter the details for your class. In the Add Class window, enter StackLinked in the text box titled Class Name. Assure that none of the option boxes towards the bottom are checked. Once this is completed, click the OK button towards the bottom right. Preparing Your Pre-Implementation Files Implement the StackLinked Class Header using the code given below. In order to implement the methods needed, you must first let the IDE know the names of those methods. To do this, simply copy the code in the box below to your StackLinked.h file. A stack can have many implementations which range in complexity; however, here you will be implementing the most fundamental and most well-known version, which will consist of isEmpty, push, and pop. In Visual Studio, once you have coded the signatures in StackLinked.h, it will likely show you an error until you code the definitions in the StackLinked.cpp file; there is no need to worry as you will do just this in the coming steps. #include <stdexcept>\nusing namespace std;\n\ntemplate <typename DataType>\nclass StackLinked {\n  public:\n    StackLinked( );    // Constructor\n    ~StackLinked( );  // Destructor\n\n    // Member functions\n    void push( const DataType& newDataItem );\n    DataType pop( ) throw ( logic_error );\n    bool isEmpty( ) const;\n\n    // Display Stack (Testing and Debugging)\n    void showStructure() const;\n\n  private:\n   /* \n    *                             !!!!! NOTE  !!!!! :  \n    *  LEAVE ROOM HERE TO INSERT --- Node Class --- IN THE NEXT STEP >\n    */\nStackNode* top;  // Ptr to remember top of stack\n}; Implement StackNode in the StackLinked Class. Since this stack implementation utilizes a Linked List, which is just a chain of connected boxes (nodes) containing data, you will need to include the StackNode class. To do this, again, simply copy paste the code from below to your StackLinked.h file. This will allow the implementation to make the boxes and connect them together. It is crucial that you do this step carefully, for if this is not done correctly then nothing else will work. Furthermore, if done incorrectly, this may result in memory leak; which will not be good for you computer. You can think of this as the basic building block for your stack. // Node Class (Each item in stack is one node, insert this in the same file as above)\nclass StackNode {\n    public:\n        StackNode(const DataType& nodeData, StackNode* nextPtr) {\n            dataItem = nodeData;\n            next = nextPtr;\n        }\n\n    DataType dataItem;  // Data stored in node\n    StackNode* next;     // Pointer holding the address of the next node\n}; Implementing the Code for Stack Implement the Constructor. To implement this, initialize the top pointer to nullptr. This is telling the computer that, for now, don't point to any memory address in specific, but be ready to shortly. This is require because, logically, it is impossible to use something that isn't built. Ensure to include comments in your code to help you better understand. The run time complexity of this is O(1). /* \n* Default Constructor\n* Method to initialize all class variables\n* PreCondition - None\n* PostCondition - top is initialized\n*/\n// Class Member top is initialized to nullptr\ntemplate <typename DataType>\nStackLinked<DataType>::StackLinked ( ) {\n    top = nullptr;  // initialize value\n} Implement the Destructor. The destructor will deallocate all the nodes in the stack. To deallocate a node: \n First, reference the top node with a temporary node (to remember the location). Second, move the top node to the next (previous) item. Think of this like a stack of boxes, to reduce the size, you take one box off at a time. Lastly, deallocate the memory taken by the previous node with the temporary node created. Repeat this process until the stack is empty to destruct entire stack  \nSince the nodes dynamically allocate memory, which means they ask the computer for space to put their data, they must be deallocated when no longer needed. If the class does not have a destructor, then it will lead to memory leak. The complexity of this method is O(n). /*\n* Destructor\n* Method will deallocate all space taken by the stack\n* PreCondition - None ( No operations preformed is stack if empty )\n* PostCondition - top = nullptr ( No Nodes in Stack )\n*/\n// All nodes in stack are deallocated \ntemplate <typename DataType>\nStackLinked<DataType>::~StackLinked( ) {\n    StackNode* traverse; // Temp NodePtr\n    \n    while ( !this->empty( ) ) { // Stop when no nodes left\n        traverse = top;        // Remember the previous top node\n        top = top->next; // Move top node to the next node\n        delete traverse;       // Deallocate the top node stored at start \n    }\n}\n \n\n Implement the push. The push method adds a data item to the top of the stack. In layman's terms, it will add another \"box of data\" on top of the existing \"boxes of data\". In order to do this, you ask the computer for more space, put whatever data you want in there, then connect the last \"box of data\" to your new \"box of data\". Think of this either like stacking boxes, or adding train cars on to a train. In order to add a train car, you first have to get a train car and fill it with things, then link the old train car to your new one. The complexity of this method is O(1). // Method to insert an item at the top of the stack\n// \tnewDataItem: Data item that will be inserted on top of stack\ntemplate <typename DataType>\nvoid StackLinked<DataType>::push( const DataType& newDataItem ) {\n    // Allocate new node with newDataItem and link to previous top\n    StackNode* t = new StackNode ( newDataItem, top ); \n    top = t;\t\t   // Insert item to top of stack\n}\n \n \n Implement the pop. The functionality of pop is to remove the top item of the stack. Since you are using a linked list (connected boxes), be very careful to make sure you are deallocating the memory correctly. First, store the data in the top node so you can return it to the user. Second, create a new node that is referencing the memory location of the top node. Third, reduce the size of the stack by moving the top node to the next item (your new top ). Lastly, you must delete the node being referenced by the temporary node you have created and return the data item that was stored at the position. Referring back to the train analogy, you want to take all things out of your train car, tell someone to hold it so it doesn't roll away when you remove it, unlink it from the next train car, and then destroy it because you don't need it any more. The complexity of this method is O(1). // Method will remove the top member of the stack \n// (most recently inserted) and return that data (PostCondition)\n// \tFunction will throw Stack is not empty\ntemplate <typename DataType>\nDataType StackLinked<DataType>::pop() throw (logic_error) {\n\tif ( !this->empty( ) ) {\n\t\tDataType d = top->dataItem;  // Hold data at the top of stack\n\t\tStackNode* t = top;\t\t\t// Temp. store address of top\n\t\ttop = top->next;\t\t\t// Advance top to now reference next item\n\t\tdelete t;\t\t\t\t\t// Deallocate the space being used by previous top\n\t\treturn d;\t\t\t\t\t// Return data stored in the previous top node\n\t} else {  \t// PreCondition is that the stack cannot be empty\n\t\tthrow  logic_error(\"Error: Pop was unsuccessful. Make sure stack is not empty. \");\n\t}\n}\n \n  \n Implement isEmpty. The functionality of isEmpty is exactly as you would expect: it will simply determine if there are any items in the stack. To do this, you can simply check if the top node is referencing anything. If it is, then you know that it is not empty because there is data there; otherwise you know that it is empty because it doesn't have any space to hold anything. You can do this because you know that the top will hold the most recent item; therefore if the most recent item is nothing this implies that there in nothing before it. Again referring to the train analogy, if you want to know a train is empty, then you just check if the train engine car is linked to or contains anything. As for the boxes analogy, you just check if there's a box; if there is not, then there is nothing. The complexity of this method is O(1). // Will determine if list is empty ( No space taken by stack )\n// PreCondition: None\n// PostCondition: Return either true or false\ntemplate <typename DataType>\nbool StackLinked<DataType>:: isEmpty( ) const {\n\treturn ( top == nullptr );\n} Testing the Implementation Add a new file to your project. Now that the stack has been implemented, validate the implementation behavior. To do this, create a testStack.cpp file by using the keyboard short cut Ctrl+N and renaming the file testStack.cpp. Alternatively, right click the source folder and select Add new item, rename this item testStack.cpp. Add the following code in the test file. Insert the code below in the testStack.cpp file created in the last step. This code will test all the functions you have implemented. Make sure to read the project description, which outlines the specifications and test cases. Needless to say, testing implementations is very important, because if you coded something that doesn't work, then there wasn't really any purpose in doing it. More importantly, when working with dynamic allocation should not produce any memory leaks, stack overflows, etc. ///////////////////// -- PROJECT DESCRIPTION -- ////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  \n//  Testing File for Stack Data Structure\n//  \n//  SPECIFICATIONS:\n//  \n//  \tPush:  \n//  \t\tShould add item to top of stack\n//\n//  \tPop:   \n//  \t\tShould remove item from top of stack\n//  \t\t\n//\tEmpty: \n//\t\tShould say \"empty stack\" if no items otherwise \n//\t\tsay \"not empty stack\"\n//\t\t\t\n//\toperator= :\n//\t\tShould make a copy of a stack (right hand side) \n//\t\tin other stack (left hand side)\n//\n//\tStack<DataType> exampleStack: \n//\t\tShould make a empty stack\n//\t\t\n//\tStack<DataType> temp(oldStack): \n//\t\tShould copy items from oldstack and put them in temp\n//\t\tstack\n//\t\t\t\n//\tTEST CASES:\n//\t\n//\t\tSTEP NO. |\tCOMMAND   |   RESULT\n// \t\t------------------------------------------------------\n//\t\t   1\t          |  +a+b+c\t      |   [c] b a\n//\t\t   2\t          |  --\t  \t              |   [a]\n//\t\t   3\t          |  E\t\t              |   Stack is NOT empty\n//\t\t   4\t          |  +e\t \t      |   [e] a\n//\t\t   5\t          |  C\t\t      |\t  Stack is empty\n//\t\t   6\t          |  Q\t\t      |\t  N/A\n//\t\t   \n//\tPASS CRITERIA FOR IMPLEMENTATION:\n//\t\t- All Test Cases above produce proper result\n//\t\t- All Stack specifications are followed\n//\t\t- No Memory Leaks, Build Errors, Segmentation Faults, etc. //\t\t\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////  Header Files and Namespaces - DO NOT DELETE ////////////////////////\n#include <iostream>\t\t// For cout <<\n#include <iomanip>\t\t\t// For formatted output\n#include \"StackLinked.cpp\"\t// To use your stack implementation\nusing namespace std;\t\t// Use items in std namespace (std::)\n////////////  Header Files and Namespaces - DO NOT DELETE ////////////////////////\n\n//////////// SHOW STRUCTURE - TESTING AND DEBUGGING //////////////////////\n/*\n* Outputs the data items in a stack. * If the stack is empty, outputs \"Empty stack\". */\ntemplate <typename DataType>\nvoid StackLinked<DataType>::showStructure() const {\n    if( isEmpty() ) {\n\tcout << \"Empty stack\" << endl;\n    } else {\n        cout << \"Top\\t\";\n\tfor (StackNode* temp = top; temp != 0; temp = temp->next) {\n\t    if( temp == top ) {\n\t\tcout << \"[\" << temp->dataItem << \"]\\t\";\n\t    } else {\n\t\tcout << temp->dataItem << \"\\t\";\n\t    }\n\t}\n        cout << \"Bottom\" << endl;\n    }\n}\n//////////// SHOW STRUCTURE - TESTING AND DEBUGGING //////////////////////\n\n////////////  TESTING MENU - START ///////////////////////////\nvoid testMenu( ) {\n    cout << setw( 20 ) << left << \"Command\"\n    \t << setw( 20 ) << left << \"Description\" << endl;\n    cout << setw( 20 ) << left << \"H\"\n    \t << setw( 20 ) << left << \"Show Help Menu.\" << endl;\n    cout << setw( 20 ) << left << \"+[item]\"\n    \t << setw( 20 ) << left << \"Push item ([item]) to stack. '[item]' is a placeholder. (ex. +a will add 'a' to stack.)\" << endl;\n    cout << setw( 20 ) << left << \"-\"\n    \t << setw( 20 ) << left << \"Pop item from stack. Will remove last inserted item to stack.\" << endl;\n    cout << setw( 20 ) << left << \"E\"\n    \t << setw( 20 ) << left << \"Check if stack is empty\" << endl;\n    cout << setw( 20 ) << left << \"Q\"\n    \t << setw( 20 ) << left << \"Terminate testing.\" << endl << endl;\n}\n////////////  TESTING MENU - END  ///////////////////////////////\n\nint main() {\n    cout << \"Testing Stack Data Structure Implementation\" << endl;\n    cout << \"-----------------------------------------------------------\" << endl;\n    \n    StackLinked<char> testStack;  // Stack\n    char testDataItem, cmd; \t      // Stack data item, Input Command\n    testMenu();\t\t\t              // Show Command Menu\n\n    // TESTING LOOP (READ CMD -> PREFORM OPERATION)\n    do {\n        testStack.showStructure();                              // Output stack\n        cout << endl << \"Command: \";  cin >> cmd;\t// Read command\n        \n\ttry {\n\t    switch ( cmd ) {\n\t      case 'H' : case 'h': testMenu(); break;\n\t      case '+' : cin >> testDataItem; testStack.push(testDataItem); break;\n\t      case '-' : cout << \"Popped \" << testStack.pop() << endl; break;\n\t      case 'Q' : case 'q' : break;\n\t      case 'E' : case 'e' : cout << ( ( testStack.isEmpty() ) ? ( \"Stack is empty\\n\" ) : \n\t      \t\t( \"Stack is NOT empty\\n\") ); break;\n\t      default : cout << cmd << \"is an invalid command. Enter H to see menu.\" << endl;\n             }\n          } catch ( logic_error _stackError ) {\n\t      cout << \"ERROR: \" << _stackError.what() << endl;\n\t  }\n    } while ( cin && cmd != 'Q' && cmd != 'q' );\n} Run tests. Sometimes when implementing functions, you will run in to errors; however there is no need to worry. This simply means that, either you told the computer to do something other than what you intended or the computer simply doesn't understand what you are telling it to do. Common bugs faced when implementing a stack include: \n Not incrementing your top node member which results in each push simply overwriting the previous item \n Not correctly deallocating a node in the pop and destructor methods which results in the computer showing memory leak or \"segmentation fault\" errors. Naturally, it is nearly impossible to outline the solution for every problem that could occur here; however having a solid approach to debugging methods is often a universal solution. See how to develop this approach below, even if you did not face any errors in your implementation. Debugging Walk through the particular function or program that has an issue. Visualize what each line of code is doing. This will help with targeting the issue. Comment and clean up your code and identifiers. This will help both you and others read the code and identify where a particular function isn't working according to specification. Research the gaps in your understanding. If you are not completely sure what a particular function, operator, or generally any line in your code is doing, then break it down to find what exactly you aren't able to piece together and search it on the internet. It is highly likely you are not the first person to have that question. In doing this, do not simply solve the problem, understand why it occurred so you become less likely to do it in the future. When the code gets more complex and the number of errors is not decreasing, this will cause increasing frustration. Ask a friend or colleague to also take a look at your code. It is possibly that you are skipping over some detail that a new set eyes may be able to see. However, your code must be well formatted so they can understand, further implicating the importance of following coding conventions. Step back and take a break from the code. Attempt to mentally run through how the code should be working, possibly think of a better way to do the same function, or just don't think about the whole program at all to refresh your thinking. Once you have found a possibly solution or have relaxed your mind, get back and attempt to solve it again. More often than not, you will be able to see the mistake being made. Set breakpoints at lines where you think the program is failing. If you are utilizing an IDE, then you can set breakpoints at specific lines of code; this will tell the computer to stop running for a moment so that you can see exactly what it has already done and predicate what it will do next. This will often show you exactly why the program is failing to execute how you want it.",
    "sentences": [
        " Configuring the Initial Environment Open your IDE (Integrated Development Environment).",
        "If you are using Visual Studio, you can open it by pressing the Windows Key and then searching for \"Visual Studio\".",
        "An IDE is required to run your program.",
        "If you do not have an IDE installed, install one prior to continuing with this article.",
        "Though no particular IDE is required, the initial environment configuration steps in this project will be demonstrated in Visual Studio.",
        "If you are already familiar with configuring an environment and creating a class, then do so and proceed to part two, where you will begin implementing the stack class.",
        "You can use How to Install Visual Studio (Windows) or How to Install and Configure Xcode (Mac OS X) to help with installation.",
        "Create a new project.",
        "You must create a new project to group all the code that is associated with the specific goal you are trying to achieve.",
        "This helps with organization as sometimes the specific goal you are trying to achieve may require a substantial amount of code.",
        "In Visual Studio, use the keyboard shortcut Ctrl+\u21e7 Shift+N to open a new project..",
        "In the rare case your Project does not open to a CLR Project (Clear Project), create a new C++ CLR Project by clicking on:\nInstalled (Side Panel)\nVisual C++ (Side Panel)\nCLR (Side Panel)\nCLR Empty Project (Center view) Enter the details for your project.",
        "At the bottom of your New Project window, there will three text boxes: Name, Location, Solution Name.",
        "Though it is not required, you probably want to fill them to help decipher between other projects.",
        "After you have entered these, click the \"OK\" button at the bottom right.",
        "Name: stackType <Something Indicative of the Project>\nLocation: Browse for your Documents folder <Anywhere you can access easily>\nSolution Name: stackType <Something Indicative of this specific module> Add a class to your project.",
        "In Visual Studio, the easiest way to add class is to simply use the keyboard shortcut Ctrl+\u21e7 Shift+X.",
        "Once the window title Class Wizard opens, click the Add Class button towards the top right.",
        "Enter the details for your class.",
        "In the Add Class window, enter StackLinked in the text box titled Class Name.",
        "Assure that none of the option boxes towards the bottom are checked.",
        "Once this is completed, click the OK button towards the bottom right.",
        "Preparing Your Pre-Implementation Files Implement the StackLinked Class Header using the code given below.",
        "In order to implement the methods needed, you must first let the IDE know the names of those methods.",
        "To do this, simply copy the code in the box below to your StackLinked.h file.",
        "A stack can have many implementations which range in complexity; however, here you will be implementing the most fundamental and most well-known version, which will consist of isEmpty, push, and pop.",
        "In Visual Studio, once you have coded the signatures in StackLinked.h, it will likely show you an error until you code the definitions in the StackLinked.cpp file; there is no need to worry as you will do just this in the coming steps.",
        "#include <stdexcept>\nusing namespace std;\n\ntemplate <typename DataType>\nclass StackLinked {\n  public:\n    StackLinked( );    // Constructor\n    ~StackLinked( );  // Destructor\n\n    // Member functions\n    void push( const DataType& newDataItem );\n    DataType pop( ) throw ( logic_error );\n    bool isEmpty( ) const;\n\n    // Display Stack (Testing and Debugging)\n    void showStructure() const;\n\n  private:\n   /* \n    *                             !!!!!",
        "NOTE  !!!!!",
        ":  \n    *  LEAVE ROOM HERE TO INSERT --- Node Class --- IN THE NEXT STEP >\n    */\nStackNode* top;  // Ptr to remember top of stack\n}; Implement StackNode in the StackLinked Class.",
        "Since this stack implementation utilizes a Linked List, which is just a chain of connected boxes (nodes) containing data, you will need to include the StackNode class.",
        "To do this, again, simply copy paste the code from below to your StackLinked.h file.",
        "This will allow the implementation to make the boxes and connect them together.",
        "It is crucial that you do this step carefully, for if this is not done correctly then nothing else will work.",
        "Furthermore, if done incorrectly, this may result in memory leak; which will not be good for you computer.",
        "You can think of this as the basic building block for your stack.",
        "// Node Class (Each item in stack is one node, insert this in the same file as above)\nclass StackNode {\n    public:\n        StackNode(const DataType& nodeData, StackNode* nextPtr) {\n            dataItem = nodeData;\n            next = nextPtr;\n        }\n\n    DataType dataItem;  // Data stored in node\n    StackNode* next;     // Pointer holding the address of the next node\n}; Implementing the Code for Stack Implement the Constructor.",
        "To implement this, initialize the top pointer to nullptr.",
        "This is telling the computer that, for now, don't point to any memory address in specific, but be ready to shortly.",
        "This is require because, logically, it is impossible to use something that isn't built.",
        "Ensure to include comments in your code to help you better understand.",
        "The run time complexity of this is O(1).",
        "/* \n* Default Constructor\n* Method to initialize all class variables\n* PreCondition - None\n* PostCondition - top is initialized\n*/\n// Class Member top is initialized to nullptr\ntemplate <typename DataType>\nStackLinked<DataType>::StackLinked ( ) {\n    top = nullptr;  // initialize value\n} Implement the Destructor.",
        "The destructor will deallocate all the nodes in the stack.",
        "To deallocate a node: \n First, reference the top node with a temporary node (to remember the location).",
        "Second, move the top node to the next (previous) item.",
        "Think of this like a stack of boxes, to reduce the size, you take one box off at a time.",
        "Lastly, deallocate the memory taken by the previous node with the temporary node created.",
        "Repeat this process until the stack is empty to destruct entire stack  \nSince the nodes dynamically allocate memory, which means they ask the computer for space to put their data, they must be deallocated when no longer needed.",
        "If the class does not have a destructor, then it will lead to memory leak.",
        "The complexity of this method is O(n).",
        "/*\n* Destructor\n* Method will deallocate all space taken by the stack\n* PreCondition - None ( No operations preformed is stack if empty )\n* PostCondition - top = nullptr ( No Nodes in Stack )\n*/\n// All nodes in stack are deallocated \ntemplate <typename DataType>\nStackLinked<DataType>::~StackLinked( ) {\n    StackNode* traverse; // Temp NodePtr\n    \n    while ( !this->empty( ) ) { // Stop when no nodes left\n        traverse = top;        // Remember the previous top node\n        top = top->next; // Move top node to the next node\n        delete traverse;       // Deallocate the top node stored at start \n    }\n}\n \n\n Implement the push.",
        "The push method adds a data item to the top of the stack.",
        "In layman's terms, it will add another \"box of data\" on top of the existing \"boxes of data\".",
        "In order to do this, you ask the computer for more space, put whatever data you want in there, then connect the last \"box of data\" to your new \"box of data\".",
        "Think of this either like stacking boxes, or adding train cars on to a train.",
        "In order to add a train car, you first have to get a train car and fill it with things, then link the old train car to your new one.",
        "The complexity of this method is O(1).",
        "// Method to insert an item at the top of the stack\n// \tnewDataItem: Data item that will be inserted on top of stack\ntemplate <typename DataType>\nvoid StackLinked<DataType>::push( const DataType& newDataItem ) {\n    // Allocate new node with newDataItem and link to previous top\n    StackNode* t = new StackNode ( newDataItem, top ); \n    top = t;\t\t   // Insert item to top of stack\n}\n \n \n Implement the pop.",
        "The functionality of pop is to remove the top item of the stack.",
        "Since you are using a linked list (connected boxes), be very careful to make sure you are deallocating the memory correctly.",
        "First, store the data in the top node so you can return it to the user.",
        "Second, create a new node that is referencing the memory location of the top node.",
        "Third, reduce the size of the stack by moving the top node to the next item (your new top ).",
        "Lastly, you must delete the node being referenced by the temporary node you have created and return the data item that was stored at the position.",
        "Referring back to the train analogy, you want to take all things out of your train car, tell someone to hold it so it doesn't roll away when you remove it, unlink it from the next train car, and then destroy it because you don't need it any more.",
        "The complexity of this method is O(1).",
        "// Method will remove the top member of the stack \n// (most recently inserted) and return that data (PostCondition)\n// \tFunction will throw Stack is not empty\ntemplate <typename DataType>\nDataType StackLinked<DataType>::pop() throw (logic_error) {\n\tif ( !this->empty( ) ) {\n\t\tDataType d = top->dataItem;  // Hold data at the top of stack\n\t\tStackNode* t = top;\t\t\t// Temp.",
        "store address of top\n\t\ttop = top->next;\t\t\t// Advance top to now reference next item\n\t\tdelete t;\t\t\t\t\t// Deallocate the space being used by previous top\n\t\treturn d;\t\t\t\t\t// Return data stored in the previous top node\n\t} else {  \t// PreCondition is that the stack cannot be empty\n\t\tthrow  logic_error(\"Error: Pop was unsuccessful.",
        "Make sure stack is not empty.",
        "\");\n\t}\n}\n \n  \n Implement isEmpty.",
        "The functionality of isEmpty is exactly as you would expect: it will simply determine if there are any items in the stack.",
        "To do this, you can simply check if the top node is referencing anything.",
        "If it is, then you know that it is not empty because there is data there; otherwise you know that it is empty because it doesn't have any space to hold anything.",
        "You can do this because you know that the top will hold the most recent item; therefore if the most recent item is nothing this implies that there in nothing before it.",
        "Again referring to the train analogy, if you want to know a train is empty, then you just check if the train engine car is linked to or contains anything.",
        "As for the boxes analogy, you just check if there's a box; if there is not, then there is nothing.",
        "The complexity of this method is O(1).",
        "// Will determine if list is empty ( No space taken by stack )\n// PreCondition: None\n// PostCondition: Return either true or false\ntemplate <typename DataType>\nbool StackLinked<DataType>:: isEmpty( ) const {\n\treturn ( top == nullptr );\n} Testing the Implementation Add a new file to your project.",
        "Now that the stack has been implemented, validate the implementation behavior.",
        "To do this, create a testStack.cpp file by using the keyboard short cut Ctrl+N and renaming the file testStack.cpp.",
        "Alternatively, right click the source folder and select Add new item, rename this item testStack.cpp.",
        "Add the following code in the test file.",
        "Insert the code below in the testStack.cpp file created in the last step.",
        "This code will test all the functions you have implemented.",
        "Make sure to read the project description, which outlines the specifications and test cases.",
        "Needless to say, testing implementations is very important, because if you coded something that doesn't work, then there wasn't really any purpose in doing it.",
        "More importantly, when working with dynamic allocation should not produce any memory leaks, stack overflows, etc.",
        "///////////////////// -- PROJECT DESCRIPTION -- ////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  \n//  Testing File for Stack Data Structure\n//  \n//  SPECIFICATIONS:\n//  \n//  \tPush:  \n//  \t\tShould add item to top of stack\n//\n//  \tPop:   \n//  \t\tShould remove item from top of stack\n//  \t\t\n//\tEmpty: \n//\t\tShould say \"empty stack\" if no items otherwise \n//\t\tsay \"not empty stack\"\n//\t\t\t\n//\toperator= :\n//\t\tShould make a copy of a stack (right hand side) \n//\t\tin other stack (left hand side)\n//\n//\tStack<DataType> exampleStack: \n//\t\tShould make a empty stack\n//\t\t\n//\tStack<DataType> temp(oldStack): \n//\t\tShould copy items from oldstack and put them in temp\n//\t\tstack\n//\t\t\t\n//\tTEST CASES:\n//\t\n//\t\tSTEP NO.",
        "|\tCOMMAND   |   RESULT\n// \t\t------------------------------------------------------\n//\t\t   1\t          |  +a+b+c\t      |   [c] b a\n//\t\t   2\t          |  --\t  \t              |   [a]\n//\t\t   3\t          |  E\t\t              |   Stack is NOT empty\n//\t\t   4\t          |  +e\t \t      |   [e] a\n//\t\t   5\t          |  C\t\t      |\t  Stack is empty\n//\t\t   6\t          |  Q\t\t      |\t  N/A\n//\t\t   \n//\tPASS CRITERIA FOR IMPLEMENTATION:\n//\t\t- All Test Cases above produce proper result\n//\t\t- All Stack specifications are followed\n//\t\t- No Memory Leaks, Build Errors, Segmentation Faults, etc.",
        "//\t\t\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////  Header Files and Namespaces - DO NOT DELETE ////////////////////////\n#include <iostream>\t\t// For cout <<\n#include <iomanip>\t\t\t// For formatted output\n#include \"StackLinked.cpp\"\t// To use your stack implementation\nusing namespace std;\t\t// Use items in std namespace (std::)\n////////////  Header Files and Namespaces - DO NOT DELETE ////////////////////////\n\n//////////// SHOW STRUCTURE - TESTING AND DEBUGGING //////////////////////\n/*\n* Outputs the data items in a stack.",
        "* If the stack is empty, outputs \"Empty stack\".",
        "*/\ntemplate <typename DataType>\nvoid StackLinked<DataType>::showStructure() const {\n    if( isEmpty() ) {\n\tcout << \"Empty stack\" << endl;\n    } else {\n        cout << \"Top\\t\";\n\tfor (StackNode* temp = top; temp != 0; temp = temp->next) {\n\t    if( temp == top ) {\n\t\tcout << \"[\" << temp->dataItem << \"]\\t\";\n\t    } else {\n\t\tcout << temp->dataItem << \"\\t\";\n\t    }\n\t}\n        cout << \"Bottom\" << endl;\n    }\n}\n//////////// SHOW STRUCTURE - TESTING AND DEBUGGING //////////////////////\n\n////////////  TESTING MENU - START ///////////////////////////\nvoid testMenu( ) {\n    cout << setw( 20 ) << left << \"Command\"\n    \t << setw( 20 ) << left << \"Description\" << endl;\n    cout << setw( 20 ) << left << \"H\"\n    \t << setw( 20 ) << left << \"Show Help Menu.\"",
        "<< endl;\n    cout << setw( 20 ) << left << \"+[item]\"\n    \t << setw( 20 ) << left << \"Push item ([item]) to stack.",
        "'[item]' is a placeholder.",
        "(ex.",
        "+a will add 'a' to stack.)\"",
        "<< endl;\n    cout << setw( 20 ) << left << \"-\"\n    \t << setw( 20 ) << left << \"Pop item from stack.",
        "Will remove last inserted item to stack.\"",
        "<< endl;\n    cout << setw( 20 ) << left << \"E\"\n    \t << setw( 20 ) << left << \"Check if stack is empty\" << endl;\n    cout << setw( 20 ) << left << \"Q\"\n    \t << setw( 20 ) << left << \"Terminate testing.\"",
        "<< endl << endl;\n}\n////////////  TESTING MENU - END  ///////////////////////////////\n\nint main() {\n    cout << \"Testing Stack Data Structure Implementation\" << endl;\n    cout << \"-----------------------------------------------------------\" << endl;\n    \n    StackLinked<char> testStack;  // Stack\n    char testDataItem, cmd; \t      // Stack data item, Input Command\n    testMenu();\t\t\t              // Show Command Menu\n\n    // TESTING LOOP (READ CMD -> PREFORM OPERATION)\n    do {\n        testStack.showStructure();                              // Output stack\n        cout << endl << \"Command: \";  cin >> cmd;\t// Read command\n        \n\ttry {\n\t    switch ( cmd ) {\n\t      case 'H' : case 'h': testMenu(); break;\n\t      case '+' : cin >> testDataItem; testStack.push(testDataItem); break;\n\t      case '-' : cout << \"Popped \" << testStack.pop() << endl; break;\n\t      case 'Q' : case 'q' : break;\n\t      case 'E' : case 'e' : cout << ( ( testStack.isEmpty() ) ?",
        "( \"Stack is empty\\n\" ) : \n\t      \t\t( \"Stack is NOT empty\\n\") ); break;\n\t      default : cout << cmd << \"is an invalid command.",
        "Enter H to see menu.\"",
        "<< endl;\n             }\n          } catch ( logic_error _stackError ) {\n\t      cout << \"ERROR: \" << _stackError.what() << endl;\n\t  }\n    } while ( cin && cmd != 'Q' && cmd != 'q' );\n} Run tests.",
        "Sometimes when implementing functions, you will run in to errors; however there is no need to worry.",
        "This simply means that, either you told the computer to do something other than what you intended or the computer simply doesn't understand what you are telling it to do.",
        "Common bugs faced when implementing a stack include: \n Not incrementing your top node member which results in each push simply overwriting the previous item \n Not correctly deallocating a node in the pop and destructor methods which results in the computer showing memory leak or \"segmentation fault\" errors.",
        "Naturally, it is nearly impossible to outline the solution for every problem that could occur here; however having a solid approach to debugging methods is often a universal solution.",
        "See how to develop this approach below, even if you did not face any errors in your implementation.",
        "Debugging Walk through the particular function or program that has an issue.",
        "Visualize what each line of code is doing.",
        "This will help with targeting the issue.",
        "Comment and clean up your code and identifiers.",
        "This will help both you and others read the code and identify where a particular function isn't working according to specification.",
        "Research the gaps in your understanding.",
        "If you are not completely sure what a particular function, operator, or generally any line in your code is doing, then break it down to find what exactly you aren't able to piece together and search it on the internet.",
        "It is highly likely you are not the first person to have that question.",
        "In doing this, do not simply solve the problem, understand why it occurred so you become less likely to do it in the future.",
        "When the code gets more complex and the number of errors is not decreasing, this will cause increasing frustration.",
        "Ask a friend or colleague to also take a look at your code.",
        "It is possibly that you are skipping over some detail that a new set eyes may be able to see.",
        "However, your code must be well formatted so they can understand, further implicating the importance of following coding conventions.",
        "Step back and take a break from the code.",
        "Attempt to mentally run through how the code should be working, possibly think of a better way to do the same function, or just don't think about the whole program at all to refresh your thinking.",
        "Once you have found a possibly solution or have relaxed your mind, get back and attempt to solve it again.",
        "More often than not, you will be able to see the mistake being made.",
        "Set breakpoints at lines where you think the program is failing.",
        "If you are utilizing an IDE, then you can set breakpoints at specific lines of code; this will tell the computer to stop running for a moment so that you can see exactly what it has already done and predicate what it will do next.",
        "This will often show you exactly why the program is failing to execute how you want it."
    ]
}