{
    "title": "How to Make a GUI Calculator with Tkinter",
    "url": "https://www.wikihow.com/Make-a-GUI-Calculator-with-Tkinter",
    "category_hierarchy": [
        "Computers and Electronics",
        "Software",
        "Programming",
        "Python"
    ],
    "steps": [
        {
            "headline": "Open a text editor or IDE.",
            "description": "If you don't prefer a specific program, it's easiest to use IDLE, an IDE that is usually installed together with Python."
        },
        {
            "headline": "Import Tkinter.",
            "description": "It is usually installed together with Python, so you don't have to install anything new. Write the following line at the beginning of your program:\n\nfrom tkinter import *\nfrom tkinter import messagebox # has to be imported separately"
        },
        {
            "headline": "Save and run the program to test that Tkinter is installed correctly.",
            "description": "If it works, you won't see anything, the program will just import Tkinter and exit. If it doesn't work (i. e. some error message appears), the next steps also won't work until you fix the problem."
        },
        {
            "headline": "Define a Window subclass of the Frame class.",
            "description": "This subclass will define what the calculator window will look like. For now, just include the basic code that initializes a window:\n\nclass Window(Frame):\n        def __init__(self, master=None):\n                Frame.__init__(self, master)\n                self.master = master"
        },
        {
            "headline": "Make the window show up.",
            "description": "You have already defined what a window looks like, but you also need to actually create a window. Call the Tk() function to initialize Tkinter and and return an object that will let you control the main window. Create a window of the Window class that is attached to that object. Set a caption for the window. Show the window and react to events. root = Tk()\napp = Window(root)\nroot.wm_title(\"Calculator\")\nroot.mainloop()"
        },
        {
            "headline": "Add a text field.",
            "description": "This is where you'll display the calculation and its result. The first function in the following code creates a text box that has white background, black text and is 1 line high. The second function actually inserts the text, which is \"0\". This code belongs into the __init__() function of the Window class. # Creating result text field\n                self.resultField = Text(master, bg=\"#FFFFFF\", fg=\"#000000\", height=1)\n                self.resultField.insert(INSERT, \"0\")"
        },
        {
            "headline": "Place the text field in the grid.",
            "description": "The grid will position your widgets, like the text field and the buttons. Since the grid should be at the top, place it in row 0. Since it's across the entire row, which will be 4 columns wide, it's not necessary to specify a column number, but you need to specify that it spans across 4 columns. self.resultField.grid(row=0, columnspan=4)"
        },
        {
            "headline": "Create and align the number and operation buttons.",
            "description": "The callback function for every button will be self.notice with what is written on the button as argument. Since you can't use functions with arguments directly as callback function, you'll have to put it into a lambda instruction. For now, define that function to pass (do nothing) or to print that value. # Creating number and operation buttons\n                b1 = Button(master, text=\"1\", command=lambda: self.notice(1))\n                b2 = Button(master, text=\"2\", command=lambda: self.notice(2))\n                b3 = Button(master, text=\"3\", command=lambda: self.notice(3))\n                bPlus = Button(master, text=\"+\", command=lambda: self.notice(\"+\"))\n                b4 = Button(master, text=\"4\", command=lambda: self.notice(4))\n                b5 = Button(master, text=\"5\", command=lambda: self.notice(5))\n                b6 = Button(master, text=\"6\", command=lambda: self.notice(6))\n                bMinus = Button(master, text=\"-\", command=lambda: self.notice(\"-\"))\n                b7 = Button(master, text=\"7\", command=lambda: self.notice(7))\n                b8 = Button(master, text=\"8\", command=lambda: self.notice(8))\n                b9 = Button(master, text=\"9\", command=lambda: self.notice(9))\n                bMultip = Button(master, text=\"*\", command=lambda: self.notice(\"*\"))\n                b0 = Button(master, text=\"0\", command=lambda: self.notice(0))\n                bLeft = Button(master, text=\"(\", command=lambda: self.notice(\"(\"))\n                bRight = Button(master, text=\")\", command=lambda: self.notice(\")\"))\n                bDivide = Button(master, text=\"/\", command=lambda: self.notice(\"/\"))\n# Aligning number and operation buttons\n                b1.grid(row=1, column=0)\n                b2.grid(row=1, column=1)\n                b3.grid(row=1, column=2)\n                bPlus.grid(row=1, column=3)\n                b4.grid(row=2, column=0)\n                b5.grid(row=2, column=1)\n                b6.grid(row=2, column=2)\n                bMinus.grid(row=2, column=3)\n                b7.grid(row=3, column=0)\n                b8.grid(row=3, column=1)\n                b9.grid(row=3, column=2)\n                bMultip.grid(row=3, column=3)\n                b0.grid(row=4, column=0)\n                bLeft.grid(row=4, column=1)\n                bRight.grid(row=4, column=2)\n                bDivide.grid(row=4, column=3)\n        def notice(self, num):\n                print(num)"
        },
        {
            "headline": "Save and run the file to test whether the buttons are aligned correctly.",
            "description": "If not, adjust the position. While the buttons, window and field can look differently on different systems, it should approximately look like this:{\"smallUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/5\\/52\\/Python3-tkinter-calculator-number-buttons.png\",\"bigUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/5\\/52\\/Python3-tkinter-calculator-number-buttons.png\",\"smallWidth\":460,\"smallHeight\":527,\"bigWidth\":760,\"bigHeight\":870.1449275362319,\"licensing\":\"<div class=\\\"mw-parser-output\\\"><p>License: <a rel=\\\"nofollow\\\" class=\\\"external text\\\" href=\\\"https:\\/\\/en.wikipedia.org\\/wiki\\/Fair_use\\\">Fair Use<\\/a> (screenshot)<br>\\n<\\/p><\\/div>\"}"
        },
        {
            "headline": "Write the self.notice function.",
            "description": "You already defined it so that displaying the button works, but the code doesn't do what it's supposed to do yet. Instead of printing the value, it should display it on the result field to show the user that the calculator noticed their input. Usually, the program can just append the value, but if the only thing present in the calculation field is the number 0, that 0 should be removed and replaced by the value. The \"0.0\" that is present in the get() and delete() functions indicates the beginning of the textbox text. It follows the format \"lineNumber.columnNumber\", which is used for indexing textbox text. def notice(self, num):\n                if self.resultField.get(\"0.0\", END) == \"0\\n\":\n                        self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(num))"
        },
        {
            "headline": "Add buttons to calculate and clear.",
            "description": "Right now, it's only possible to enter numbers and operations. But a calculator should actually calculate the result of what the user enters. When that calculation is finished, it should be possible to clear the output and calculate something else. To do these things, add two more buttons in row 5. To visually set them off from the others, make them span across 2 columns. Set self.displayRes and self.clear as the callback functions. # Creating and aligning calculation buttons\n                bCalculate = Button(master, text=\"=\", command=self.displayRes)\n                bClear = Button(master, text=\"Clear\", command=self.clear)\n                bCalculate.grid(row=5, column=0, columnspan=2)\n                bClear.grid(row=5, column=2, columnspan=2)"
        },
        {
            "headline": "Define the clear() function.",
            "description": "It should delete all text in the textbox and replace it with a 0.\n\ndef clear(self):\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, \"0\")"
        },
        {
            "headline": "Define a function to display the result of the calculation.",
            "description": "The actual calculation function will be quite complex, and it would be even more complex if it also had to get the input from the text box and write the output into it. This is why you should define another function for this. def displayRes(self):\n                res = self.calculate(self.resultField.get(\"0.0\",END)[:-1])\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(res))"
        },
        {
            "headline": "Define the calculation function.",
            "description": "This is the most complex function of the entire program. Make it recursive, i. e. calling itself with other arguments. This allows it to reduce the expression to simpler expressions until it's only a number, then perform the specified operation with the number and the other number, then use that result in the not-so-simple expression, and so on. Don't proceed if the input is \"ERROR\". That string will be used to indicate that a calculation failed. Since it's not possible to continue calculating with a failed result, the function should just return \"ERROR\" itself. def calculate(self, task):\n                if task == \"ERROR\":\n                        return \"ERROR\" # don't proceed if error happened in underlying call\n\n\n\n  Check whether the input is a single number. If it is, return that number, since there's nothing left to calculate. Note that the following expression will raise a ValueError if the input isn't a single number. The actual calculation and recursion happens when such an error occurs. try:\n                        return(float(task))\n                except ValueError:\n\n\n\n  Check whether there are brackets. If so, calculate the result of the expression inside the brackets separately from the other things. If not, proceed to check other operations. if \")\" in task:\n                                level = 0\n                                maxLevelStartIndex = 0\n                                maxLevelEndIndex = 0\n                                for i in range(0, len(task)):\n                                        if task[i] == \"(\":\n                                                level += 1\n                                                maxLevelStartIndex = i\n                                        if task[i] == \")\":\n                                                level -= 1\n                                if level != 0:\n                                        print(\"ERROR: brackets don't match: %i layers too much in expression %s\" %(level, task))\n                                        return \"ERROR\"\n                                for i in range(maxLevelStartIndex, len(task)):\n                                        if task[i] == \")\":\n                                                maxLevelEndIndex = i\n                                                break\n                                newTask = task[:maxLevelStartIndex] + str(self.calculate(task[maxLevelStartIndex+1:maxLevelEndIndex])) + task[maxLevelEndIndex+1:]\n                                return self.calculate(newTask)\n\n\n\n  Other operations (add, subtract, multiply, divide) are arranged by priority. The program splits by the + or - first and calculates the two parts, only then by the * or / . Note that it catches the error that happens when you try to divide by 0, and returns \"ERROR\" if that happens. If there is no error, it returns the result. elif \"+\" in task:\n                                tesk = task.split(\"+\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res += self.calculate(t)\n                                return res\n                        elif \"-\" in task:\n                                tesk = task.split(\"-\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res -= self.calculate(t)\n                                return res\n                        elif \"*\" in task:\n                                tesk = task.split(\"*\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res *= self.calculate(t)\n                                return res\n                        elif \"/\" in task:\n                                tesk = task.split(\"/\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        try:\n                                                res /= self.calculate(t)\n                                        except ZeroDivisionError:\n                                                print(\"ERROR: division by 0\")\n                                                return \"ERROR\"\n                                return res\n\n\n\nIf the input could not be converted to a number not because it's an expression, but for another reason, that returns an error. This is necessary because the Tkinter text field allows the user to enter input on the keyboard. If the user enters a letter, that should return an error, and this code makes sure it does. print(\"ERROR: invalid expression\")\n                                return \"ERROR\""
        },
        {
            "headline": "Make graphical error messages.",
            "description": "Right now, if an error happens, it displays \"ERROR\" on the result text field and prints the error to the terminal or IDE from which you started Python. But a good GUI should also display the errors graphically. This is done with the messagebox.showerror function. It takes the message heading as first argument and message text as second. You can use \"Error\" as message heading and the message that was previously printed as message. For example, replace \n\nprint(\"ERROR: division by 0\")\n\n with \n\nmessagebox.showerror(\"Error\", \"ERROR: division by 0\")"
        },
        {
            "headline": "Check your code.",
            "description": "Your entire code should look like this now. from tkinter import *\nfrom tkinter import messagebox\nclass Window(Frame):\n        def __init__(self, master=None):\n                Frame.__init__(self, master)\n                self.master = master\n# Creating result text field\n                self.resultField = Text(master, bg=\"#FFFFFF\", fg=\"#000000\", height=1, width=20)\n                self.resultField.insert(INSERT, \"0\")\n                self.resultField.grid(row=0, columnspan=4)\n# Creating number and operation buttons\n                b1 = Button(master, text=\"1\", command=lambda: self.notice(1))\n                b2 = Button(master, text=\"2\", command=lambda: self.notice(2))\n                b3 = Button(master, text=\"3\", command=lambda: self.notice(3))\n                bPlus = Button(master, text=\"+\", command=lambda: self.notice(\"+\"))\n                b4 = Button(master, text=\"4\", command=lambda: self.notice(4))\n                b5 = Button(master, text=\"5\", command=lambda: self.notice(5))\n                b6 = Button(master, text=\"6\", command=lambda: self.notice(6))\n                bMinus = Button(master, text=\"-\", command=lambda: self.notice(\"-\"))\n                b7 = Button(master, text=\"7\", command=lambda: self.notice(7))\n                b8 = Button(master, text=\"8\", command=lambda: self.notice(8))\n                b9 = Button(master, text=\"9\", command=lambda: self.notice(9))\n                bMultip = Button(master, text=\"*\", command=lambda: self.notice(\"*\"))\n                b0 = Button(master, text=\"0\", command=lambda: self.notice(0))\n                bLeft = Button(master, text=\"(\", command=lambda: self.notice(\"(\"))\n                bRight = Button(master, text=\")\", command=lambda: self.notice(\")\"))\n                bDivide = Button(master, text=\"/\", command=lambda: self.notice(\"/\"))\n# Aligning number and operation buttons\n                b1.grid(row=1, column=0)\n                b2.grid(row=1, column=1)\n                b3.grid(row=1, column=2)\n                bPlus.grid(row=1, column=3)\n                b4.grid(row=2, column=0)\n                b5.grid(row=2, column=1)\n                b6.grid(row=2, column=2)\n                bMinus.grid(row=2, column=3)\n                b7.grid(row=3, column=0)\n                b8.grid(row=3, column=1)\n                b9.grid(row=3, column=2)\n                bMultip.grid(row=3, column=3)\n                b0.grid(row=4, column=0)\n                bLeft.grid(row=4, column=1)\n                bRight.grid(row=4, column=2)\n                bDivide.grid(row=4, column=3)\n# Creating and aligning calculation buttons\n                bCalculate = Button(master, text=\"=\", command=self.displayRes)\n                bClear = Button(master, text=\"Clear\", command=self.clear)\n                bCalculate.grid(row=5, column=0, columnspan=2)\n                bClear.grid(row=5, column=2, columnspan=2)\n        def notice(self, num):\n                if self.resultField.get(\"0.0\", END) == \"0\\n\":\n                        self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(num))\n        def clear(self):\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, \"0\")\n        def displayRes(self):\n                res = self.calculate(self.resultField.get(\"0.0\",END)[:-1])\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(res))\n        def calculate(self, task):\n                if task == \"ERROR\":\n                        return \"ERROR\" # don't proceed if error happened in underlying call\n                try:\n                        return(float(task))\n                except ValueError:\n                        if \")\" in task:\n                                level = 0\n                                maxLevelStartIndex = 0\n                                maxLevelEndIndex = 0\n                                for i in range(0, len(task)):\n                                        if task[i] == \"(\":\n                                                level += 1\n                                                maxLevelStartIndex = i\n                                        if task[i] == \")\":\n                                                level -= 1\n                                if level != 0:\n                                        messagebox.showerror(\"Error\", \"ERROR: brackets don't match: %i layers too much in expression %s\" %(level, task))\n                                        return \"ERROR\"\n                                for i in range(maxLevelStartIndex, len(task)):\n                                        if task[i] == \")\":\n                                                maxLevelEndIndex = i\n                                                break\n                                newTask = task[:maxLevelStartIndex] + str(self.calculate(task[maxLevelStartIndex+1:maxLevelEndIndex])) + task[maxLevelEndIndex+1:]\n                                return self.calculate(newTask)\n                        elif \"+\" in task:\n                                tesk = task.split(\"+\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res += self.calculate(t)\n                                return res\n                        elif \"-\" in task:\n                                tesk = task.split(\"-\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res -= self.calculate(t)\n                                return res\n                        elif \"*\" in task:\n                                tesk = task.split(\"*\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res *= self.calculate(t)\n                                return res\n                        elif \"/\" in task:\n                                tesk = task.split(\"/\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        try:\n                                                res /= self.calculate(t)\n                                        except ZeroDivisionError:\n                                                messagebox.showerror(\"Error\", \"ERROR: division by 0\")\n                                                return \"ERROR\"\n                                return res\n                        else:\n                                messagebox.showerror(\"Error\", \"ERROR: invalid expression\")\n                                return \"ERROR\"\nroot = Tk()\napp = Window(root)\nroot.wm_title(\"Calculator\")\nroot.mainloop()\n\nThis are 120 lines totally, and 116 lines not counting the comments."
        },
        {
            "headline": "Save and run the code.",
            "description": "It's finished. Now test it and/or enjoy your own calculator. It should look approximately like in this screenshot:{\"smallUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/1\\/15\\/Python3-tkinter-calculator-finished.png\",\"bigUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/1\\/15\\/Python3-tkinter-calculator-finished.png\",\"smallWidth\":460,\"smallHeight\":613,\"bigWidth\":760,\"bigHeight\":1013.3333333333334,\"licensing\":\"<div class=\\\"mw-parser-output\\\"><p>License: <a rel=\\\"nofollow\\\" class=\\\"external text\\\" href=\\\"https:\\/\\/en.wikipedia.org\\/wiki\\/Fair_use\\\">Fair Use<\\/a> (screenshot)<br>\\n<\\/p><\\/div>\"}"
        }
    ],
    "tyn": [
        "Computer",
        "Python 3"
    ],
    "text": " Open a text editor or IDE. If you don't prefer a specific program, it's easiest to use IDLE, an IDE that is usually installed together with Python. Import Tkinter. It is usually installed together with Python, so you don't have to install anything new. Write the following line at the beginning of your program:\n\nfrom tkinter import *\nfrom tkinter import messagebox # has to be imported separately Save and run the program to test that Tkinter is installed correctly. If it works, you won't see anything, the program will just import Tkinter and exit. If it doesn't work (i. e. some error message appears), the next steps also won't work until you fix the problem. Define a Window subclass of the Frame class. This subclass will define what the calculator window will look like. For now, just include the basic code that initializes a window:\n\nclass Window(Frame):\n        def __init__(self, master=None):\n                Frame.__init__(self, master)\n                self.master = master Make the window show up. You have already defined what a window looks like, but you also need to actually create a window. Call the Tk() function to initialize Tkinter and and return an object that will let you control the main window. Create a window of the Window class that is attached to that object. Set a caption for the window. Show the window and react to events. root = Tk()\napp = Window(root)\nroot.wm_title(\"Calculator\")\nroot.mainloop() Add a text field. This is where you'll display the calculation and its result. The first function in the following code creates a text box that has white background, black text and is 1 line high. The second function actually inserts the text, which is \"0\". This code belongs into the __init__() function of the Window class. # Creating result text field\n                self.resultField = Text(master, bg=\"#FFFFFF\", fg=\"#000000\", height=1)\n                self.resultField.insert(INSERT, \"0\") Place the text field in the grid. The grid will position your widgets, like the text field and the buttons. Since the grid should be at the top, place it in row 0. Since it's across the entire row, which will be 4 columns wide, it's not necessary to specify a column number, but you need to specify that it spans across 4 columns. self.resultField.grid(row=0, columnspan=4) Create and align the number and operation buttons. The callback function for every button will be self.notice with what is written on the button as argument. Since you can't use functions with arguments directly as callback function, you'll have to put it into a lambda instruction. For now, define that function to pass (do nothing) or to print that value. # Creating number and operation buttons\n                b1 = Button(master, text=\"1\", command=lambda: self.notice(1))\n                b2 = Button(master, text=\"2\", command=lambda: self.notice(2))\n                b3 = Button(master, text=\"3\", command=lambda: self.notice(3))\n                bPlus = Button(master, text=\"+\", command=lambda: self.notice(\"+\"))\n                b4 = Button(master, text=\"4\", command=lambda: self.notice(4))\n                b5 = Button(master, text=\"5\", command=lambda: self.notice(5))\n                b6 = Button(master, text=\"6\", command=lambda: self.notice(6))\n                bMinus = Button(master, text=\"-\", command=lambda: self.notice(\"-\"))\n                b7 = Button(master, text=\"7\", command=lambda: self.notice(7))\n                b8 = Button(master, text=\"8\", command=lambda: self.notice(8))\n                b9 = Button(master, text=\"9\", command=lambda: self.notice(9))\n                bMultip = Button(master, text=\"*\", command=lambda: self.notice(\"*\"))\n                b0 = Button(master, text=\"0\", command=lambda: self.notice(0))\n                bLeft = Button(master, text=\"(\", command=lambda: self.notice(\"(\"))\n                bRight = Button(master, text=\")\", command=lambda: self.notice(\")\"))\n                bDivide = Button(master, text=\"/\", command=lambda: self.notice(\"/\"))\n# Aligning number and operation buttons\n                b1.grid(row=1, column=0)\n                b2.grid(row=1, column=1)\n                b3.grid(row=1, column=2)\n                bPlus.grid(row=1, column=3)\n                b4.grid(row=2, column=0)\n                b5.grid(row=2, column=1)\n                b6.grid(row=2, column=2)\n                bMinus.grid(row=2, column=3)\n                b7.grid(row=3, column=0)\n                b8.grid(row=3, column=1)\n                b9.grid(row=3, column=2)\n                bMultip.grid(row=3, column=3)\n                b0.grid(row=4, column=0)\n                bLeft.grid(row=4, column=1)\n                bRight.grid(row=4, column=2)\n                bDivide.grid(row=4, column=3)\n        def notice(self, num):\n                print(num) Save and run the file to test whether the buttons are aligned correctly. If not, adjust the position. While the buttons, window and field can look differently on different systems, it should approximately look like this:{\"smallUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/5\\/52\\/Python3-tkinter-calculator-number-buttons.png\",\"bigUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/5\\/52\\/Python3-tkinter-calculator-number-buttons.png\",\"smallWidth\":460,\"smallHeight\":527,\"bigWidth\":760,\"bigHeight\":870.1449275362319,\"licensing\":\"<div class=\\\"mw-parser-output\\\"><p>License: <a rel=\\\"nofollow\\\" class=\\\"external text\\\" href=\\\"https:\\/\\/en.wikipedia.org\\/wiki\\/Fair_use\\\">Fair Use<\\/a> (screenshot)<br>\\n<\\/p><\\/div>\"} Write the self.notice function. You already defined it so that displaying the button works, but the code doesn't do what it's supposed to do yet. Instead of printing the value, it should display it on the result field to show the user that the calculator noticed their input. Usually, the program can just append the value, but if the only thing present in the calculation field is the number 0, that 0 should be removed and replaced by the value. The \"0.0\" that is present in the get() and delete() functions indicates the beginning of the textbox text. It follows the format \"lineNumber.columnNumber\", which is used for indexing textbox text. def notice(self, num):\n                if self.resultField.get(\"0.0\", END) == \"0\\n\":\n                        self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(num)) Add buttons to calculate and clear. Right now, it's only possible to enter numbers and operations. But a calculator should actually calculate the result of what the user enters. When that calculation is finished, it should be possible to clear the output and calculate something else. To do these things, add two more buttons in row 5. To visually set them off from the others, make them span across 2 columns. Set self.displayRes and self.clear as the callback functions. # Creating and aligning calculation buttons\n                bCalculate = Button(master, text=\"=\", command=self.displayRes)\n                bClear = Button(master, text=\"Clear\", command=self.clear)\n                bCalculate.grid(row=5, column=0, columnspan=2)\n                bClear.grid(row=5, column=2, columnspan=2) Define the clear() function. It should delete all text in the textbox and replace it with a 0.\n\ndef clear(self):\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, \"0\") Define a function to display the result of the calculation. The actual calculation function will be quite complex, and it would be even more complex if it also had to get the input from the text box and write the output into it. This is why you should define another function for this. def displayRes(self):\n                res = self.calculate(self.resultField.get(\"0.0\",END)[:-1])\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(res)) Define the calculation function. This is the most complex function of the entire program. Make it recursive, i. e. calling itself with other arguments. This allows it to reduce the expression to simpler expressions until it's only a number, then perform the specified operation with the number and the other number, then use that result in the not-so-simple expression, and so on. Don't proceed if the input is \"ERROR\". That string will be used to indicate that a calculation failed. Since it's not possible to continue calculating with a failed result, the function should just return \"ERROR\" itself. def calculate(self, task):\n                if task == \"ERROR\":\n                        return \"ERROR\" # don't proceed if error happened in underlying call\n\n\n\n  Check whether the input is a single number. If it is, return that number, since there's nothing left to calculate. Note that the following expression will raise a ValueError if the input isn't a single number. The actual calculation and recursion happens when such an error occurs. try:\n                        return(float(task))\n                except ValueError:\n\n\n\n  Check whether there are brackets. If so, calculate the result of the expression inside the brackets separately from the other things. If not, proceed to check other operations. if \")\" in task:\n                                level = 0\n                                maxLevelStartIndex = 0\n                                maxLevelEndIndex = 0\n                                for i in range(0, len(task)):\n                                        if task[i] == \"(\":\n                                                level += 1\n                                                maxLevelStartIndex = i\n                                        if task[i] == \")\":\n                                                level -= 1\n                                if level != 0:\n                                        print(\"ERROR: brackets don't match: %i layers too much in expression %s\" %(level, task))\n                                        return \"ERROR\"\n                                for i in range(maxLevelStartIndex, len(task)):\n                                        if task[i] == \")\":\n                                                maxLevelEndIndex = i\n                                                break\n                                newTask = task[:maxLevelStartIndex] + str(self.calculate(task[maxLevelStartIndex+1:maxLevelEndIndex])) + task[maxLevelEndIndex+1:]\n                                return self.calculate(newTask)\n\n\n\n  Other operations (add, subtract, multiply, divide) are arranged by priority. The program splits by the + or - first and calculates the two parts, only then by the * or / . Note that it catches the error that happens when you try to divide by 0, and returns \"ERROR\" if that happens. If there is no error, it returns the result. elif \"+\" in task:\n                                tesk = task.split(\"+\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res += self.calculate(t)\n                                return res\n                        elif \"-\" in task:\n                                tesk = task.split(\"-\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res -= self.calculate(t)\n                                return res\n                        elif \"*\" in task:\n                                tesk = task.split(\"*\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res *= self.calculate(t)\n                                return res\n                        elif \"/\" in task:\n                                tesk = task.split(\"/\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        try:\n                                                res /= self.calculate(t)\n                                        except ZeroDivisionError:\n                                                print(\"ERROR: division by 0\")\n                                                return \"ERROR\"\n                                return res\n\n\n\nIf the input could not be converted to a number not because it's an expression, but for another reason, that returns an error. This is necessary because the Tkinter text field allows the user to enter input on the keyboard. If the user enters a letter, that should return an error, and this code makes sure it does. print(\"ERROR: invalid expression\")\n                                return \"ERROR\" Make graphical error messages. Right now, if an error happens, it displays \"ERROR\" on the result text field and prints the error to the terminal or IDE from which you started Python. But a good GUI should also display the errors graphically. This is done with the messagebox.showerror function. It takes the message heading as first argument and message text as second. You can use \"Error\" as message heading and the message that was previously printed as message. For example, replace \n\nprint(\"ERROR: division by 0\")\n\n with \n\nmessagebox.showerror(\"Error\", \"ERROR: division by 0\") Check your code. Your entire code should look like this now. from tkinter import *\nfrom tkinter import messagebox\nclass Window(Frame):\n        def __init__(self, master=None):\n                Frame.__init__(self, master)\n                self.master = master\n# Creating result text field\n                self.resultField = Text(master, bg=\"#FFFFFF\", fg=\"#000000\", height=1, width=20)\n                self.resultField.insert(INSERT, \"0\")\n                self.resultField.grid(row=0, columnspan=4)\n# Creating number and operation buttons\n                b1 = Button(master, text=\"1\", command=lambda: self.notice(1))\n                b2 = Button(master, text=\"2\", command=lambda: self.notice(2))\n                b3 = Button(master, text=\"3\", command=lambda: self.notice(3))\n                bPlus = Button(master, text=\"+\", command=lambda: self.notice(\"+\"))\n                b4 = Button(master, text=\"4\", command=lambda: self.notice(4))\n                b5 = Button(master, text=\"5\", command=lambda: self.notice(5))\n                b6 = Button(master, text=\"6\", command=lambda: self.notice(6))\n                bMinus = Button(master, text=\"-\", command=lambda: self.notice(\"-\"))\n                b7 = Button(master, text=\"7\", command=lambda: self.notice(7))\n                b8 = Button(master, text=\"8\", command=lambda: self.notice(8))\n                b9 = Button(master, text=\"9\", command=lambda: self.notice(9))\n                bMultip = Button(master, text=\"*\", command=lambda: self.notice(\"*\"))\n                b0 = Button(master, text=\"0\", command=lambda: self.notice(0))\n                bLeft = Button(master, text=\"(\", command=lambda: self.notice(\"(\"))\n                bRight = Button(master, text=\")\", command=lambda: self.notice(\")\"))\n                bDivide = Button(master, text=\"/\", command=lambda: self.notice(\"/\"))\n# Aligning number and operation buttons\n                b1.grid(row=1, column=0)\n                b2.grid(row=1, column=1)\n                b3.grid(row=1, column=2)\n                bPlus.grid(row=1, column=3)\n                b4.grid(row=2, column=0)\n                b5.grid(row=2, column=1)\n                b6.grid(row=2, column=2)\n                bMinus.grid(row=2, column=3)\n                b7.grid(row=3, column=0)\n                b8.grid(row=3, column=1)\n                b9.grid(row=3, column=2)\n                bMultip.grid(row=3, column=3)\n                b0.grid(row=4, column=0)\n                bLeft.grid(row=4, column=1)\n                bRight.grid(row=4, column=2)\n                bDivide.grid(row=4, column=3)\n# Creating and aligning calculation buttons\n                bCalculate = Button(master, text=\"=\", command=self.displayRes)\n                bClear = Button(master, text=\"Clear\", command=self.clear)\n                bCalculate.grid(row=5, column=0, columnspan=2)\n                bClear.grid(row=5, column=2, columnspan=2)\n        def notice(self, num):\n                if self.resultField.get(\"0.0\", END) == \"0\\n\":\n                        self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(num))\n        def clear(self):\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, \"0\")\n        def displayRes(self):\n                res = self.calculate(self.resultField.get(\"0.0\",END)[:-1])\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(res))\n        def calculate(self, task):\n                if task == \"ERROR\":\n                        return \"ERROR\" # don't proceed if error happened in underlying call\n                try:\n                        return(float(task))\n                except ValueError:\n                        if \")\" in task:\n                                level = 0\n                                maxLevelStartIndex = 0\n                                maxLevelEndIndex = 0\n                                for i in range(0, len(task)):\n                                        if task[i] == \"(\":\n                                                level += 1\n                                                maxLevelStartIndex = i\n                                        if task[i] == \")\":\n                                                level -= 1\n                                if level != 0:\n                                        messagebox.showerror(\"Error\", \"ERROR: brackets don't match: %i layers too much in expression %s\" %(level, task))\n                                        return \"ERROR\"\n                                for i in range(maxLevelStartIndex, len(task)):\n                                        if task[i] == \")\":\n                                                maxLevelEndIndex = i\n                                                break\n                                newTask = task[:maxLevelStartIndex] + str(self.calculate(task[maxLevelStartIndex+1:maxLevelEndIndex])) + task[maxLevelEndIndex+1:]\n                                return self.calculate(newTask)\n                        elif \"+\" in task:\n                                tesk = task.split(\"+\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res += self.calculate(t)\n                                return res\n                        elif \"-\" in task:\n                                tesk = task.split(\"-\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res -= self.calculate(t)\n                                return res\n                        elif \"*\" in task:\n                                tesk = task.split(\"*\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res *= self.calculate(t)\n                                return res\n                        elif \"/\" in task:\n                                tesk = task.split(\"/\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        try:\n                                                res /= self.calculate(t)\n                                        except ZeroDivisionError:\n                                                messagebox.showerror(\"Error\", \"ERROR: division by 0\")\n                                                return \"ERROR\"\n                                return res\n                        else:\n                                messagebox.showerror(\"Error\", \"ERROR: invalid expression\")\n                                return \"ERROR\"\nroot = Tk()\napp = Window(root)\nroot.wm_title(\"Calculator\")\nroot.mainloop()\n\nThis are 120 lines totally, and 116 lines not counting the comments. Save and run the code. It's finished. Now test it and/or enjoy your own calculator. It should look approximately like in this screenshot:{\"smallUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/1\\/15\\/Python3-tkinter-calculator-finished.png\",\"bigUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/1\\/15\\/Python3-tkinter-calculator-finished.png\",\"smallWidth\":460,\"smallHeight\":613,\"bigWidth\":760,\"bigHeight\":1013.3333333333334,\"licensing\":\"<div class=\\\"mw-parser-output\\\"><p>License: <a rel=\\\"nofollow\\\" class=\\\"external text\\\" href=\\\"https:\\/\\/en.wikipedia.org\\/wiki\\/Fair_use\\\">Fair Use<\\/a> (screenshot)<br>\\n<\\/p><\\/div>\"}",
    "sentences": [
        " Open a text editor or IDE.",
        "If you don't prefer a specific program, it's easiest to use IDLE, an IDE that is usually installed together with Python.",
        "Import Tkinter.",
        "It is usually installed together with Python, so you don't have to install anything new.",
        "Write the following line at the beginning of your program:\n\nfrom tkinter import *\nfrom tkinter import messagebox # has to be imported separately Save and run the program to test that Tkinter is installed correctly.",
        "If it works, you won't see anything, the program will just import Tkinter and exit.",
        "If it doesn't work (i. e. some error message appears), the next steps also won't work until you fix the problem.",
        "Define a Window subclass of the Frame class.",
        "This subclass will define what the calculator window will look like.",
        "For now, just include the basic code that initializes a window:\n\nclass Window(Frame):\n        def __init__(self, master=None):\n                Frame.__init__(self, master)\n                self.master = master Make the window show up.",
        "You have already defined what a window looks like, but you also need to actually create a window.",
        "Call the Tk() function to initialize Tkinter and and return an object that will let you control the main window.",
        "Create a window of the Window class that is attached to that object.",
        "Set a caption for the window.",
        "Show the window and react to events.",
        "root = Tk()\napp = Window(root)\nroot.wm_title(\"Calculator\")\nroot.mainloop() Add a text field.",
        "This is where you'll display the calculation and its result.",
        "The first function in the following code creates a text box that has white background, black text and is 1 line high.",
        "The second function actually inserts the text, which is \"0\".",
        "This code belongs into the __init__() function of the Window class.",
        "# Creating result text field\n                self.resultField = Text(master, bg=\"#FFFFFF\", fg=\"#000000\", height=1)\n                self.resultField.insert(INSERT, \"0\") Place the text field in the grid.",
        "The grid will position your widgets, like the text field and the buttons.",
        "Since the grid should be at the top, place it in row 0.",
        "Since it's across the entire row, which will be 4 columns wide, it's not necessary to specify a column number, but you need to specify that it spans across 4 columns.",
        "self.resultField.grid(row=0, columnspan=4) Create and align the number and operation buttons.",
        "The callback function for every button will be self.notice with what is written on the button as argument.",
        "Since you can't use functions with arguments directly as callback function, you'll have to put it into a lambda instruction.",
        "For now, define that function to pass (do nothing) or to print that value.",
        "# Creating number and operation buttons\n                b1 = Button(master, text=\"1\", command=lambda: self.notice(1))\n                b2 = Button(master, text=\"2\", command=lambda: self.notice(2))\n                b3 = Button(master, text=\"3\", command=lambda: self.notice(3))\n                bPlus = Button(master, text=\"+\", command=lambda: self.notice(\"+\"))\n                b4 = Button(master, text=\"4\", command=lambda: self.notice(4))\n                b5 = Button(master, text=\"5\", command=lambda: self.notice(5))\n                b6 = Button(master, text=\"6\", command=lambda: self.notice(6))\n                bMinus = Button(master, text=\"-\", command=lambda: self.notice(\"-\"))\n                b7 = Button(master, text=\"7\", command=lambda: self.notice(7))\n                b8 = Button(master, text=\"8\", command=lambda: self.notice(8))\n                b9 = Button(master, text=\"9\", command=lambda: self.notice(9))\n                bMultip = Button(master, text=\"*\", command=lambda: self.notice(\"*\"))\n                b0 = Button(master, text=\"0\", command=lambda: self.notice(0))\n                bLeft = Button(master, text=\"(\", command=lambda: self.notice(\"(\"))\n                bRight = Button(master, text=\")\", command=lambda: self.notice(\")\"))\n                bDivide = Button(master, text=\"/\", command=lambda: self.notice(\"/\"))\n# Aligning number and operation buttons\n                b1.grid(row=1, column=0)\n                b2.grid(row=1, column=1)\n                b3.grid(row=1, column=2)\n                bPlus.grid(row=1, column=3)\n                b4.grid(row=2, column=0)\n                b5.grid(row=2, column=1)\n                b6.grid(row=2, column=2)\n                bMinus.grid(row=2, column=3)\n                b7.grid(row=3, column=0)\n                b8.grid(row=3, column=1)\n                b9.grid(row=3, column=2)\n                bMultip.grid(row=3, column=3)\n                b0.grid(row=4, column=0)\n                bLeft.grid(row=4, column=1)\n                bRight.grid(row=4, column=2)\n                bDivide.grid(row=4, column=3)\n        def notice(self, num):\n                print(num) Save and run the file to test whether the buttons are aligned correctly.",
        "If not, adjust the position.",
        "While the buttons, window and field can look differently on different systems, it should approximately look like this:{\"smallUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/5\\/52\\/Python3-tkinter-calculator-number-buttons.png\",\"bigUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/5\\/52\\/Python3-tkinter-calculator-number-buttons.png\",\"smallWidth\":460,\"smallHeight\":527,\"bigWidth\":760,\"bigHeight\":870.1449275362319,\"licensing\":\"<div class=\\\"mw-parser-output\\\"><p>License: <a rel=\\\"nofollow\\\" class=\\\"external text\\\" href=\\\"https:\\/\\/en.wikipedia.org\\/wiki\\/Fair_use\\\">Fair Use<\\/a> (screenshot)<br>\\n<\\/p><\\/div>\"} Write the self.notice function.",
        "You already defined it so that displaying the button works, but the code doesn't do what it's supposed to do yet.",
        "Instead of printing the value, it should display it on the result field to show the user that the calculator noticed their input.",
        "Usually, the program can just append the value, but if the only thing present in the calculation field is the number 0, that 0 should be removed and replaced by the value.",
        "The \"0.0\" that is present in the get() and delete() functions indicates the beginning of the textbox text.",
        "It follows the format \"lineNumber.columnNumber\", which is used for indexing textbox text.",
        "def notice(self, num):\n                if self.resultField.get(\"0.0\", END) == \"0\\n\":\n                        self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(num)) Add buttons to calculate and clear.",
        "Right now, it's only possible to enter numbers and operations.",
        "But a calculator should actually calculate the result of what the user enters.",
        "When that calculation is finished, it should be possible to clear the output and calculate something else.",
        "To do these things, add two more buttons in row 5.",
        "To visually set them off from the others, make them span across 2 columns.",
        "Set self.displayRes and self.clear as the callback functions.",
        "# Creating and aligning calculation buttons\n                bCalculate = Button(master, text=\"=\", command=self.displayRes)\n                bClear = Button(master, text=\"Clear\", command=self.clear)\n                bCalculate.grid(row=5, column=0, columnspan=2)\n                bClear.grid(row=5, column=2, columnspan=2) Define the clear() function.",
        "It should delete all text in the textbox and replace it with a 0.\n\ndef clear(self):\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, \"0\") Define a function to display the result of the calculation.",
        "The actual calculation function will be quite complex, and it would be even more complex if it also had to get the input from the text box and write the output into it.",
        "This is why you should define another function for this.",
        "def displayRes(self):\n                res = self.calculate(self.resultField.get(\"0.0\",END)[:-1])\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(res)) Define the calculation function.",
        "This is the most complex function of the entire program.",
        "Make it recursive, i. e. calling itself with other arguments.",
        "This allows it to reduce the expression to simpler expressions until it's only a number, then perform the specified operation with the number and the other number, then use that result in the not-so-simple expression, and so on.",
        "Don't proceed if the input is \"ERROR\".",
        "That string will be used to indicate that a calculation failed.",
        "Since it's not possible to continue calculating with a failed result, the function should just return \"ERROR\" itself.",
        "def calculate(self, task):\n                if task == \"ERROR\":\n                        return \"ERROR\" # don't proceed if error happened in underlying call\n\n\n\n  Check whether the input is a single number.",
        "If it is, return that number, since there's nothing left to calculate.",
        "Note that the following expression will raise a ValueError if the input isn't a single number.",
        "The actual calculation and recursion happens when such an error occurs.",
        "try:\n                        return(float(task))\n                except ValueError:\n\n\n\n  Check whether there are brackets.",
        "If so, calculate the result of the expression inside the brackets separately from the other things.",
        "If not, proceed to check other operations.",
        "if \")\" in task:\n                                level = 0\n                                maxLevelStartIndex = 0\n                                maxLevelEndIndex = 0\n                                for i in range(0, len(task)):\n                                        if task[i] == \"(\":\n                                                level += 1\n                                                maxLevelStartIndex = i\n                                        if task[i] == \")\":\n                                                level -= 1\n                                if level != 0:\n                                        print(\"ERROR: brackets don't match: %i layers too much in expression %s\" %(level, task))\n                                        return \"ERROR\"\n                                for i in range(maxLevelStartIndex, len(task)):\n                                        if task[i] == \")\":\n                                                maxLevelEndIndex = i\n                                                break\n                                newTask = task[:maxLevelStartIndex] + str(self.calculate(task[maxLevelStartIndex+1:maxLevelEndIndex])) + task[maxLevelEndIndex+1:]\n                                return self.calculate(newTask)\n\n\n\n  Other operations (add, subtract, multiply, divide) are arranged by priority.",
        "The program splits by the + or - first and calculates the two parts, only then by the * or / .",
        "Note that it catches the error that happens when you try to divide by 0, and returns \"ERROR\" if that happens.",
        "If there is no error, it returns the result.",
        "elif \"+\" in task:\n                                tesk = task.split(\"+\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res += self.calculate(t)\n                                return res\n                        elif \"-\" in task:\n                                tesk = task.split(\"-\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res -= self.calculate(t)\n                                return res\n                        elif \"*\" in task:\n                                tesk = task.split(\"*\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res *= self.calculate(t)\n                                return res\n                        elif \"/\" in task:\n                                tesk = task.split(\"/\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        try:\n                                                res /= self.calculate(t)\n                                        except ZeroDivisionError:\n                                                print(\"ERROR: division by 0\")\n                                                return \"ERROR\"\n                                return res\n\n\n\nIf the input could not be converted to a number not because it's an expression, but for another reason, that returns an error.",
        "This is necessary because the Tkinter text field allows the user to enter input on the keyboard.",
        "If the user enters a letter, that should return an error, and this code makes sure it does.",
        "print(\"ERROR: invalid expression\")\n                                return \"ERROR\" Make graphical error messages.",
        "Right now, if an error happens, it displays \"ERROR\" on the result text field and prints the error to the terminal or IDE from which you started Python.",
        "But a good GUI should also display the errors graphically.",
        "This is done with the messagebox.showerror function.",
        "It takes the message heading as first argument and message text as second.",
        "You can use \"Error\" as message heading and the message that was previously printed as message.",
        "For example, replace \n\nprint(\"ERROR: division by 0\")\n\n with \n\nmessagebox.showerror(\"Error\", \"ERROR: division by 0\") Check your code.",
        "Your entire code should look like this now.",
        "from tkinter import *\nfrom tkinter import messagebox\nclass Window(Frame):\n        def __init__(self, master=None):\n                Frame.__init__(self, master)\n                self.master = master\n# Creating result text field\n                self.resultField = Text(master, bg=\"#FFFFFF\", fg=\"#000000\", height=1, width=20)\n                self.resultField.insert(INSERT, \"0\")\n                self.resultField.grid(row=0, columnspan=4)\n# Creating number and operation buttons\n                b1 = Button(master, text=\"1\", command=lambda: self.notice(1))\n                b2 = Button(master, text=\"2\", command=lambda: self.notice(2))\n                b3 = Button(master, text=\"3\", command=lambda: self.notice(3))\n                bPlus = Button(master, text=\"+\", command=lambda: self.notice(\"+\"))\n                b4 = Button(master, text=\"4\", command=lambda: self.notice(4))\n                b5 = Button(master, text=\"5\", command=lambda: self.notice(5))\n                b6 = Button(master, text=\"6\", command=lambda: self.notice(6))\n                bMinus = Button(master, text=\"-\", command=lambda: self.notice(\"-\"))\n                b7 = Button(master, text=\"7\", command=lambda: self.notice(7))\n                b8 = Button(master, text=\"8\", command=lambda: self.notice(8))\n                b9 = Button(master, text=\"9\", command=lambda: self.notice(9))\n                bMultip = Button(master, text=\"*\", command=lambda: self.notice(\"*\"))\n                b0 = Button(master, text=\"0\", command=lambda: self.notice(0))\n                bLeft = Button(master, text=\"(\", command=lambda: self.notice(\"(\"))\n                bRight = Button(master, text=\")\", command=lambda: self.notice(\")\"))\n                bDivide = Button(master, text=\"/\", command=lambda: self.notice(\"/\"))\n# Aligning number and operation buttons\n                b1.grid(row=1, column=0)\n                b2.grid(row=1, column=1)\n                b3.grid(row=1, column=2)\n                bPlus.grid(row=1, column=3)\n                b4.grid(row=2, column=0)\n                b5.grid(row=2, column=1)\n                b6.grid(row=2, column=2)\n                bMinus.grid(row=2, column=3)\n                b7.grid(row=3, column=0)\n                b8.grid(row=3, column=1)\n                b9.grid(row=3, column=2)\n                bMultip.grid(row=3, column=3)\n                b0.grid(row=4, column=0)\n                bLeft.grid(row=4, column=1)\n                bRight.grid(row=4, column=2)\n                bDivide.grid(row=4, column=3)\n# Creating and aligning calculation buttons\n                bCalculate = Button(master, text=\"=\", command=self.displayRes)\n                bClear = Button(master, text=\"Clear\", command=self.clear)\n                bCalculate.grid(row=5, column=0, columnspan=2)\n                bClear.grid(row=5, column=2, columnspan=2)\n        def notice(self, num):\n                if self.resultField.get(\"0.0\", END) == \"0\\n\":\n                        self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(num))\n        def clear(self):\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, \"0\")\n        def displayRes(self):\n                res = self.calculate(self.resultField.get(\"0.0\",END)[:-1])\n                self.resultField.delete(\"0.0\", END)\n                self.resultField.insert(INSERT, str(res))\n        def calculate(self, task):\n                if task == \"ERROR\":\n                        return \"ERROR\" # don't proceed if error happened in underlying call\n                try:\n                        return(float(task))\n                except ValueError:\n                        if \")\" in task:\n                                level = 0\n                                maxLevelStartIndex = 0\n                                maxLevelEndIndex = 0\n                                for i in range(0, len(task)):\n                                        if task[i] == \"(\":\n                                                level += 1\n                                                maxLevelStartIndex = i\n                                        if task[i] == \")\":\n                                                level -= 1\n                                if level != 0:\n                                        messagebox.showerror(\"Error\", \"ERROR: brackets don't match: %i layers too much in expression %s\" %(level, task))\n                                        return \"ERROR\"\n                                for i in range(maxLevelStartIndex, len(task)):\n                                        if task[i] == \")\":\n                                                maxLevelEndIndex = i\n                                                break\n                                newTask = task[:maxLevelStartIndex] + str(self.calculate(task[maxLevelStartIndex+1:maxLevelEndIndex])) + task[maxLevelEndIndex+1:]\n                                return self.calculate(newTask)\n                        elif \"+\" in task:\n                                tesk = task.split(\"+\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res += self.calculate(t)\n                                return res\n                        elif \"-\" in task:\n                                tesk = task.split(\"-\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res -= self.calculate(t)\n                                return res\n                        elif \"*\" in task:\n                                tesk = task.split(\"*\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        res *= self.calculate(t)\n                                return res\n                        elif \"/\" in task:\n                                tesk = task.split(\"/\")\n                                res = self.calculate(tesk[0])\n                                for t in tesk[1:]:\n                                        try:\n                                                res /= self.calculate(t)\n                                        except ZeroDivisionError:\n                                                messagebox.showerror(\"Error\", \"ERROR: division by 0\")\n                                                return \"ERROR\"\n                                return res\n                        else:\n                                messagebox.showerror(\"Error\", \"ERROR: invalid expression\")\n                                return \"ERROR\"\nroot = Tk()\napp = Window(root)\nroot.wm_title(\"Calculator\")\nroot.mainloop()\n\nThis are 120 lines totally, and 116 lines not counting the comments.",
        "Save and run the code.",
        "It's finished.",
        "Now test it and/or enjoy your own calculator.",
        "It should look approximately like in this screenshot:{\"smallUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/1\\/15\\/Python3-tkinter-calculator-finished.png\",\"bigUrl\":\"https:\\/\\/www.wikihow.com\\/images\\/1\\/15\\/Python3-tkinter-calculator-finished.png\",\"smallWidth\":460,\"smallHeight\":613,\"bigWidth\":760,\"bigHeight\":1013.3333333333334,\"licensing\":\"<div class=\\\"mw-parser-output\\\"><p>License: <a rel=\\\"nofollow\\\" class=\\\"external text\\\" href=\\\"https:\\/\\/en.wikipedia.org\\/wiki\\/Fair_use\\\">Fair Use<\\/a> (screenshot)<br>\\n<\\/p><\\/div>\"}"
    ]
}