{
  "title":"How to Program Computer Games",
  "url":"https://www.wikihow.com/Program-Computer-Games",
  "category_hierarchy":[
    "Hobbies and Crafts",
    "Games",
    "Creating Games"
  ],
  "parts":[
    {
      "name":"Making a Text-Based Game",
      "steps":[
        {
          "headline":"Choose a programming language.",
          "description":"All programming languages are different, so you will have to decide which one to use to write your game. Every major programming language supports text input, text output and if-constructions (the main things you need for a simple text-based game), so you can decide yourself. Here are some factors to consider:\nField of application: some programming languages, like JavaScript, are designed to be used for web sites, others, like Python, C or C++, are designed to run on a computer. Some languages have one specific purpose, like R, which is mainly used for statistical analysis. For your game, you should use a language with a broader application field (Python, C, C++, JavaScript, many others). Ease of use: although writing a program should be easy enough after some practice in any normal programming language (i. e. not one specifically designed to be confusing and unusable like Malbolge), some are friendlier to beginners than others. Java and C, for example, require the programmer to understand more programming concepts than Python. Also, Python error messages are easier to understand for a beginner than, for example, C error messages. Platform compatibility: you probably want people on different systems, such as Linux, Mac or Windows, to all be able to play your game. So you shouldn't use a language that is only supported on a few systems, like for example Visual Basic, which is only supported on Windows. This is also a good reason not to code your game in Assembler, which is specific to the system and processor, and is also quite hard to program with. This article will use Python for the examples of a text-based game, but you can look up how the concepts are done in any other programming language."
        },
        {
          "headline":"Install the necessary tools.",
          "description":"You need something to compile or interpret your program with, and you need something to write/edit it with. If you want to follow the example in this article, you should install Python and learn how to run programs. If you want to, you can set up some IDE or use one that Python provides (it's called IDLE), but you can also just use your favourite text editor that supports plain text."
        },
        {
          "headline":"Print some text.",
          "description":"The player will want to know what is going on and what they have to do, so you should print some text for them. This is done with the print() function in Python. To try it out, open a new file with the .py extension, enter the following code into it, save and run it:\n\nprint(\"Welcome to the number guessing game!\") print(\"Enter a whole number between between 1 and 1000:\")"
        },
        {
          "headline":"Introduce some randomness into your game.",
          "description":"If nothing is random, the game will be exactly the same every time, and the player will get bored quickly. In this case, a number should be randomly chosen at the start of the program so that the player won't always guess the same number. Since it should remain the same throughout the program, you should store the random number in a variable. Python doesn't provide a random number function in its core. But it has a standard library (this means the user won't have to install anything extra) that does. So go to the beginning of your code (before the print() functions) and type the line import random. Use the random function. It is called randint(), is in the random library which you just imported, and takes the minimal and maximal value the number can have as argument. So go back to the end of your code and enter following line:\n\nrightNum = random.randint(0,1000)"
        },
        {
          "headline":"Get the player's input.",
          "description":"In a game, the player wants to do something or interact with something. In a text-based game, this is possible by entering text. Since the code you entered prints the instruction to enter a number to the player, it should also read the number they enter. This is done with input() in Python 3, and raw_input() in Python 2. You should write in Python 3, as Python 2 will become outdated soon. Add the following line to your code to store the player's input in a variable called number:\n\nuserNum = input()"
        },
        {
          "headline":"Turn the user's input into a usable data type.",
          "description":"Make the player's input a number. Now, this might seem confusing because they just entered a number. But there is a good reason: Python assumes that all input is text, or how it is called in programming, a string. And this text contains the number you want to get. Python provides a function to convert a string that only contains a number to the number inside. Type:\n\nuserNum = int(userNum)"
        },
        {
          "headline":"Process the user's input.",
          "description":"It would be pointless to just ask the player to enter random things. You should actually do something with the information that the user entered. Compare the user's number to the correct number. While the numbers are not the same, it should make the user enter another number. When the numbers match, it should stop getting new input, tell the user that they guessed correctly, and quit the program. This is done with the following code:\n\nwhile userNum != rightNum:\n    userNum = int(input())"
        },
        {
          "headline":"Give the player feedback.",
          "description":"While you already have processed the input, the user can't see this. You need to actually print the result to the user so they understand what's happening. Surely, you could just tell the user whether their number is right or wrong. But with that approach, the player would have to guess 1000 times in the worst case, which would be very boring. So tell the player whether their number is too small or too big. This will reduce the number of guesses significantly: If, for example, the user guesses 500 first, and is told that it's too big, there are only 500 possible numbers now instead of 1000. This is done with if-constructions, so replace the print(\"Wrong. Try again.\") with one. Be aware that checking whether two numbers are the same is done with == , not with = . = assigns the value right of it to the variable left of it! if userNum < rightNum:\n    print(\"Too small. Try again:\")\nif userNum > rightNum:\n    print(\"Too big. Try again:\")"
        },
        {
          "headline":"Test your code.",
          "description":"As a programmer, you should be sure that your code works in all cases before considering it finished. When programming in python, make sure that you get the indentations correct. Your code should look like this:\n\nimport random\nprint(\"Welcome to the number guessing game!\") print(\"Enter a whole number between 1 and 1000:\")\nrightNum = random.randint(0,1000)\nuserNum = input()\nuserNum = int(userNum)\nwhile userNum != rightNum:\n    if userNum < rightNum:\n        print(\"Too small. Try again:\")\n    if userNum > rightNum:\n        print(\"Too big. Try again:\")\n    userNum = int(input())\nprint(\"You guessed correctly.\")"
        },
        {
          "headline":"Validate the input.",
          "description":"A user shouldn't be able to break your program with simple actions like entering the wrong thing. Validating the input means whether the user entered the correct thing before processing it. Open the game again and try entering anything that's not a number. The game will exit with a ValueError. To avoid this, you should implement a way to check whether the input was a number. Define a function. Since validating the input is quite long, and you have to do it multiple times, you should define a function. It will take no arguments and return a number. First, write def numInput(): at the top of your code, directly under the import random. Get the user's input once. Use the input() function and assign the result to the variable inp. While the user's input is not a number, ask them to enter a number. Checking whether a string is a number is done with the isdigit() functions, which only allows a whole number, so you won't have to check for that separately. When the input is a number, convert it from string to number and return the result. Use the int() function for converting the string to an integer. This will make the conversion in the main code unnecessary, and you should remove it from there. Replace all calls to input() in the main code with calls to numInput(). The code of the numInput() function will look like this:\n\n\ndef numInput():\n    inp = input()\n    while not inp.isdigit():\n        print(\"You were told to enter a whole number! Enter a whole number:\")\n        inp = input()\n    return int(inp)"
        },
        {
          "headline":"Test the game again.",
          "description":"Especially pay attention to whether your input validation works by entering something wrong on purpose. Try entering some text when the program asks you for a number. Now, instead of exiting with an error message, the program will ask you for a number again."
        },
        {
          "headline":"Suggest restarting the game when it finishes.",
          "description":"This way, the player could play your game for a longer time without having to constantly restart it. Put all code except the import and the function definition into a while-loop. Set True as the condition: this will always be true, so the loop will continue forever. Ask the player whether they want to play again after they guessed the number correctly. Use the print() function. If they answer \"No\", break out of the look. If they answer anything else, continue. Breaking out of a loop is done with the break statement. Move the \"Welcome to the number guessing game\" outside the while loop. The player probably doesn't want to be welcomed every time they play the game. Move the instruction print(\"Welcome to the number guessing game!\" above the while True:, so it will be printed only once, when the user starts the first game."
        },
        {
          "headline":"Test the game.",
          "description":"You need to be sure that your game still works after implementing new features. Make sure to answer both \"Yes\" and \"No\" at least once to make sure that both options work. Here is what your code should look like:\n\nimport random\n\ndef numInput():\n    inp = input()\n    while not inp.isdigit():\n        print(\"You were told to enter a whole number! Enter a whole number:\")\n        inp = input()\n    return int(inp)\n\nprint(\"Welcome to the number guessing game!\") while True:\n    print(\"Enter a whole number between 1 and 1000:\")\n    rightNum = random.randint(0,1000)\n    userNum = numInput()\n    while userNum != rightNum:\n        if userNum < rightNum:\n            print(\"Too small. Try again:\")\n        if userNum > rightNum:\n            print(\"Too big. Try again:\")\n        userNum = numInput()\n    print(\"You guessed correctly.\") print(\"Do you want to play again? Enter No to quit.\") if input() == \"No\":\n        break"
        },
        {
          "headline":"Write other text-based games.",
          "description":"How about writing a text adventure next? Or a quiz game? Be creative. Tip: It's sometimes helpful to look in the documentation if you're not sure how something is done or how a function is used. The Python 3 documentation is found at https://docs.python.org/3/. Sometimes searching for whatever you want to do on the internet also returns good results."
        }
      ]
    },
    {
      "name":"Making a Game with 2D Graphics",
      "steps":[
        {
          "headline":"Choose a library.",
          "description":"Making graphics is very complicated, and most programming languages (including Python, C++, C, JavaScript) provide only minimal or even no support for graphics in the core or the standard libraries. So you'll have to use an external library to be able to make graphics, for example Pygame for Python. Even with a graphics library, you'll have to worry a lot about low-level things like how to display a menu, how to check whether the user clicked on it, how to display the tiles, and so on. If you prefer to focus on developing the actual game, and especially if the game you want to make is complex, you should use a game engine library, which implements such things. This article will use Python with Cocos2D to show how to make a simple 2D platformer. Some of the mentioned concepts may not exist in other game engines. Refer to their documentation for more information."
        },
        {
          "headline":"Install the library you chose.",
          "description":"Cocos2D for Python is simply installed with sudo pip3 install cocos2d."
        },
        {
          "headline":"Make a new directory.",
          "description":"You will use things like images and sounds in your game. You should keep these things in the same directory as the program, and the directory shouldn't contain anything else so that you can easily see what assets you have in the game."
        },
        {
          "headline":"Change into the new directory and create a new code file.",
          "description":"It should be named main, with the file extension of your programming language. If you write a large and complex program where it makes sense to have multiple program files, this will show which one is the main one. In this example, this file, which should be called main.py, will contain all your code. But the directory you created will still be useful for other media files."
        },
        {
          "headline":"Make a window.",
          "description":"This is the basic prerequisite for a game with graphics. You can add the simplest content now, like for example a background colour. Import the necessary cocos2d sub-modules: cocos.director, cocos.scene and cocos.layer. This is done with from subModuleName import *, where subModuleName is the submodule you want to import. The difference between from ... import * and import ... is that you don't have to put the module name in front of everything you use from that module with the former. Define a subclass MainMenuBgr of the ColorLayer. This basically means that any main menu background you create will behave like a color layer with some changes you make. Initialize the cocos director. This will give you a new window. If you don't set some caption, the window will have the same caption as the file name (main.py), which doesn't look very professional. Allow the window to be resized with by setting resizable to True. Define a function showMainMenu. You should put the code for showing the main menu into a function because this will allow you to easily return to the main menu by calling the function again. Create a scene. The scene consists of one layer for now, which is an object of the MainMenuBgr class you defined. Run this scene in the window. from cocos.director import *\nfrom cocos.scene import *\nfrom cocos.layer import *\n\nclass MainMenuBgr(ColorLayer):\n        def __init__(self):\n                super(MainMenu, self).__init__(0,200,255,255)\n\ndef showMainMenu():\n        menuSc = Scene(MainMenuBgr())\n        director.run(menuSc)\n\ndirector.init(caption=\"IcyPlat - a simple platformer\", resizable=True)\nshowMainMenu()"
        },
        {
          "headline":"Create a main menu.",
          "description":"Besides the actual game, you should have an option to close the game. You'll also add credits later, but ignore them for now. A main menu will avoid making entering the game too unexpected.Import necessary modules. You need to import cocos.menu (again with the from instruction) and pyglet.app (this time with import). Define MainMenu as a subclass of Menu. Set the alignment of the main menu. You have to set the vertical and horizontal alignment separately. Create a list of menu items and add create the actual menu. You should have the menu items \"Start Game\" and \"Quit\". Make sure to put every created menu item inside of brackets. A menu item has a label and a callback function for when it's clicked. For the \"Start Game\" item, use the startGame function (you'll write it soon), for the \"Quit\" item, use \"pyglet.app.exit\" (already exists). Create the actual menu by calling self.create_menu(menuItems). Define startGame(). Just put pass into the definition for now, you'll replace that when you write the actual game. Go to the place in your code where you created the menuSc scene, and add a MainMenu object to it. Your entire code should now look as follows:\n\nfrom cocos.director import *\nfrom cocos.menu import *\nfrom cocos.scene import *\nfrom cocos.layer import *\n\nimport pyglet.app\n\nclass MainMenuBgr(ColorLayer):\n        def __init__(self):\n                super(MainMenuBgr, self).__init__(0,200,255,255)\nclass MainMenu(Menu):\n        def __init__(self):\n                super(MainMenu, self).__init__(\"\")\n                self.menu_valign = CENTER\n                self.menu_halign = CENTER\n                menuItems = [(MenuItem(\"Start Game\", startGame)), (MenuItem(\"Quit\", pyglet.app.exit))]\n                self.create_menu(menuItems)\n\ndef startGame():\n        pass\n\ndef showMainMenu():\n        menuSc = Scene(MainMenuBgr())\n        menuSc.add(MainMenu())\n        director.run(menuSc)\ndirector.init(caption=\"IcyPlat - a simple platformer\", resizable=True)\nshowMainMenu()"
        },
        {
          "headline":"Test your code.",
          "description":"It is important to test you code at such an early stage, while it is still short and relatively simple: this way you will know any mistakes in the basic structure, and can fix them before they cause  more problems. The code from the instructions should open a window, captioned \"IcyPlat - a simple platformer\", that you can resize and that has a light blue background. It should have a menu with two items: when you click on \"Start Game\", nothing happens; when you click on \"Quit\", the program quits."
        },
        {
          "headline":"Display a sprite in the game.",
          "description":"The sprite is like a \"game object\". In a platformer, for example, one should be the main figure that the player can control (in this step, it'll only be displayed however). Things like background decorations or object the player can interact with can also be sprites, but you should only add one first to understand the concept, then you can add whatever else you want. Import the cocos.sprite submodule with the from-import-expression. Find an image. You can't display a sprite if you don't have a picture for it. You can draw one, or you can get one from the internet (watch out for the license, though, if you're planning to publish your game), for example from here (crop the image so you only have one running penguin). Make sure to put your image into the same directory as the program. Create the sprite's layer and the sprite. Create the layer as a new object of the ScrollableLayer class. Create the sprite as a Sprite object and set its position to (8, 250). For reference, the point (0, 0) is in the bottom left corner. This is quite high, but it will make sure that the penguin doesn't get stuck in the ice. Add the sprite to the sprite's layer. Create a new scene out of the sprite's layer and run it. def startGame():\n        figLayer = ScrollableLayer()\n        fig = Sprite('pingu.png')\n        fig.position = (75, 100)\n        figLayer.add(fig)\n#\n        gameSc = Scene(figLayer)\n        director.run(gameSc)\n\n\nYou can run your code now if you want. You will see a small penguin figure (or whatever you drew) on a black background after you click on \"Start Game\"."
        },
        {
          "headline":"Decide what your landscape will consist of.",
          "description":"In most games, your sprites shouldn't just float in the void. They should actually stand on some surface, with something around them. In 2D games, this is often done with a tile set and a tile map. The tile set basically says what kind of surface squares and background squares exist, and what they look like. Create a tile set. The tile set for this game will be very basic: one tile for ice and one tile for sky. The ice tile used in this example is from here, under CC-BY-SA 3.0. Create a tile set picture. That's a picture of all tiles, which have to all be of the same size (edit them if they aren't) and have the size you want to see in the game, next to each other. Save your picture as icyTiles.png. Create the tile set description. That's an XML file. The XML file contains information on how big the tiles are in the tile set picture, which picture to use, and where to find which tile there. Create an XML file named icyTiles.xml with the code below:\n\n<?xml version=\"1.0\"?>\n<resource>\n    <imageatlas size=\"16x16\" file=\"icyTiles.png\">\n        <image id=\"i-ice\" offset=\"0,0\" />\n        <image id=\"i-sky\" offset=\"16,0\" />\n    </imageatlas>\n    <tileset>\n        <tile id=\"ice\"><image ref=\"i-ice\" />\n        </tile>\n        <tile id=\"sky\"><image ref=\"i-sky\" />\n        </tile>\n    </tileset>\n</resource>"
        },
        {
          "headline":"Make an actual structure out of the elements of your landscape.",
          "description":"If you made a tile set, this should be done in the form of a tile map. A tile map is like a map that defines which tile is at which position in your level. In the example, you should define a function to generate tile maps because designing tile maps by hand is very tedious. A more advanced game would usually have some sort of level editor, but for becoming familiar with 2D game development, an algorithm can provide good enough levels. Find out how many rows and columns are needed. For this, divide the screen size by the tile size both horizontally (columns) and vertically (rows). Round the number upwards; you need a function of the math module for that, so add from math import ceil to the imports at the top of your code. Open a file for writing. This will erase all previous content of the file, so choose a name that no file in the directory has yet, like levelMap.xml. Write the opening tags into the file. Generate a tile map according to the algorithm. You use the one in the code below, or you can come up with one on your own. Make sure to import the randint function from the module random: it's required for the code below to work, and whatever you come up with will probably also need random integers. Also, make sure to put sky tiles and ice tiles in different layers: ice is solid, sky is not. Write the closing tags into the file and close the file. def generateTilemap():\n        colAmount = ceil(800 / 16)*3 # (screen width / tile size) * 3\n        rowAmount = ceil(600 / 16) # screen height / tile size\n        tileFile = open(\"levelMap.xml\",\"w\")\n        tileFile.write('<resource>\\n<requires file=\"icyTiles.xml\" />\\n<rectmap id=\"solid\" origin=\"0,0,1\" tile_size=\"16x16\">\\n')\n        iceHeight = randint(1,10)\n        for i in range(0,colAmount):\n                tileFile.write('<column>')\n                makeHole = False\n                if randint(0,50) == 10 and i != 0: # don't allow holes at the spawnpoint\n                        makeHole = True\n                for j in range(0,rowAmount):\n                        if makeHole:\n                                tileFile.write('<cell />\\n')\n                        else:\n                                if j <= iceHeight:\n                                        tileFile.write('<cell tile=\"ice\" />\\n')\n                                else:\n                                        tileFile.write('<cell />\\n')\n                iceHeight = randint(iceHeight-5, iceHeight+5)\n                if iceHeight < 0: # limit tiles from going too low\n                        iceHeight = randint(1,5)\n                if iceHeight > rowAmount: # limit tiles from going too high\n                        iceHeight = randint(int(rowAmount/2)-5,int(rowAmount/2)+5)\n                tileFile.write('</column>\\n')\n        tileFile.write('</rectmap>\\n<rectmap id=\"not_solid\" origin = \"0,0,0\" tile_size=\"16x16\">\\n')\n        for i in range(0,colAmount):\n                tileFile.write('<column>')\n                for j in range(0,rowAmount):\n                        tileFile.write('<cell tile=\"sky\" />\\n')\n                tileFile.write('</column>\\n')\n        tileFile.write('</rectmap>\\n</resource>\\n')\n        tileFile.close()"
        },
        {
          "headline":"Display the tile map.",
          "description":"Import everything from cocos.tiles and then go into the startGame function for that. At the beginning of your startGame function, generate a tile map using the function you defined for that. Create a new scrolling manager. Do this directly under the line where you add the sprite to its layer. Create a new layer containing the tiles, which will be loaded from the levelMap.xml tile map your generateTilemap function generated. Add the non-solid layer, the solid layer and the sprite layer to the scrolling manager, exactly in this order. You can add a z-position if you want. Instead of creating the scene from the sprite layer, create it from the scrolling manager. Your startGame function should now look like this:\n\ndef startGame():\n        generateTilemap()\n#\n        fig = Sprite('pingu.png')\n        fig.position = (8, 500)\n        figLayer = ScrollableLayer()\n        figLayer.add(fig)\n#\n        tileLayer = load('levelMap.xml')\n        solidTiles = tileLayer['solid']\n        nsoliTiles = tileLayer['not_solid']\n#\n        scrMang = ScrollingManager()\n        scrMang.add(nsoliTiles,z=-1)\n        scrMang.add(solidTiles,z=0)\n        scrMang.add(figLayer,z=1)\n#\n        gameSc = Scene(scrMang)\n        director.run(gameSc)"
        },
        {
          "headline":"Test your code.",
          "description":"You should test your code often to make sure that the new features you implemented really work. The code in the example should now show some icy landscape behind the penguin. If the penguin looks like it is hovering far over the ice, you didn't do anything wrong, and it will be fixed in the next step."
        },
        {
          "headline":"Add the controls.",
          "description":"The player has many more ways to interact with the program in a 2D game than in a text-based game. A common one includes moving their figure when the correct key is pressed. Import everything from cocos.mapcolliders and from cocos.actions. Also import key from pyglet.window. \"Declare\" some global variables. Global variables are shared between functions. You can't really declare variables in Python, but you have to say that a global variable exists in the main code before using it. You can assign 0 as the value because a function will take care of assigning the correct value later. So add under the import expressions:\n\n# \"declaring\" global variables\nkeyboard = 0\nscrMang = 0\n\n\n\nAdjust your startGame function:\nSay that you use the global variables keyboard and scrMang. Do this by writing global keyboard, scrMang at the top of the function. Make the window listen to keyboard events. Tell the figure to act based on a PlatformerController. You'll implement that PlatformerController soon. Create a map collider to handle collisions between the solid tiles and the figure. def startGame():\n        global keyboard, scrMang\n        generateTilemap()\n#\n        fig = Sprite('pingu.png')\n        fig.position = (8, 250)\n        figLayer = ScrollableLayer()\n        figLayer.add(fig)\n#\n        tileLayer = load('levelMap.xml')\n        solidTiles = tileLayer['solid']\n        nsoliTiles = tileLayer['not_solid']\n#\n        keyboard = key.KeyStateHandler()\n        director.window.push_handlers(keyboard)\n#\n        fig.do(PlatformerController())\n        mapcollider = RectMapCollider(velocity_on_bump='slide')\n        fig.collision_handler = make_collision_handler(mapcollider, solidTiles)\n#\n        scrMang = ScrollingManager()\n        scrMang.add(nsoliTiles,z=-1)\n        scrMang.add(solidTiles,z=0)\n        scrMang.add(figLayer,z=1)\n#\n        gameSc = Scene(scrMang)\n        director.run(gameSc)\n\n\n\nCreate a platformer controller. This is what will move the figure according to your keypresses. Define the platformer controller as a subclass of Action. Define the move speed, the jump speed and the gravity. Define the start function. This function is called once, when the platformer controller is connected to the figure. It should set its speed to 0 both in x and in y direction. Define the step function. It will be repeated while the scene is running. Tell the step function to use the global variables keyboard and scrMang. Get and change the velocity. Save the x and the y velocity in separate variables. Set the x velocity to either 1 or -1 (depending on whether the left or right key was pressed) multiplied with the move speed. Add gravity to the y velocity. Multiply it with downtime so it works the same way on slower devices. If the space key is pressed and the figure is standing on the ground, jump by changing y velocity to jump speed. Calculate to where the figure should move. Then let the collision handler adjust that position if it is inside of a solid tile. Finally, move the figure to the new adjusted position. Set the focus of the scrolling manager on the figure. This causes the camera to move in a reasonable way when the figure moves. class PlatformerController(Action):\n        global keyboard, scrMang\n        on_ground = True\n        MOVE_SPEED = 300\n        JUMP_SPEED = 500\n        GRAVITY = -1200\n        def start(self):\n                self.target.velocity = (0, 0)\n        def step(self, dt):\n                global keyboard, scroller\n                if dt > 0.1: # don't do anything while downtime to big\n                        return\n                vx, vy = self.target.velocity\n                vx = (keyboard[key.RIGHT] - keyboard[key.LEFT]) * self.MOVE_SPEED\n                vy += self.GRAVITY * dt\n                if self.on_ground and keyboard[key.SPACE]:\n                        vy = self.JUMP_SPEED\n                dx = vx * dt\n                dy = vy * dt\n                last = self.target.get_rect()\n                new = last.copy()\n                new.x += dx\n                new.y += dy\n                self.target.velocity = self.target.collision_handler(last, new, vx, vy)\n                self.on_ground = (new.y == last.y)\n                self.target.position = new.center\n                scrMang.set_focus(*new.center)"
        },
        {
          "headline":"Test your code.",
          "description":"If you followed the example, you should now be able to move the penguin with the arrow keys and jump by pressing the space bar. Also, the penguin should now fall down instead of hovering over the ground."
        },
        {
          "headline":"Let the game end.",
          "description":"Even the games that can go on endlessly have a possibility to end them by losing. And since the level you made in the example with a function has an end, it should also be possible to win by coming to that end: Else, the player would only jump around on the ice blocks there, which would get boring after some time. Inside the platformer controller, after the focus set, get the figure's x and y position. If the y position is less than 0, call the function finishGame() (you'll write it later) with \"Game Over\" as an argument. If the x position is bigger than the size of the screen multiplied with 3 (you had set that as level size before). posX, posY = self.target.position\nif posY < 0:\n        finishGame(\"Game Over\")\n        return\nif posX > 800*3: # level size\n        finishGame(\"Level Completed\")\n        return\n\n\n\nDefine a class finishMenu. It should be like the main menu class you defined before, but instead of having an empty string as title, it should use a variable text which the __init__ function takes as argument. The menu items should be labeled \"Try again\" and \"Quit\" now, but the functions they call stay the same. class FinishMenu(Menu):\n        def __init__(self, text):\n                super(FinishMenu, self).__init__(text)\n                self.menu_valign = CENTER\n                self.menu_halign = CENTER\n                menuItems = [(MenuItem(\"Try again\", startGame)), (MenuItem(\"Quit\", pyglet.app.exit))]\n                self.create_menu(menuItems)\n\n\n\nDefine the function finishGame(). It should take text as an argument. It should make a scene out of the main menu background, a FinishMenu with the text argument being passed on to this menu. Then it should run this scene. def finishGame(text):\n        menuSc = Scene(MainMenuBgr())\n        menuSc.add(FinishMenu(text))\n        director.run(menuSc)"
        },
        {
          "headline":"Add credits.",
          "description":"That's usually necessary if you used media that you didn't make yourself to credit its author. Also, you'll probably want the players to know that you wrote the game. The credits should be included in the game so that anyone who installs your game can see them without having to look deep into the game files. Create a file CREDITS and enter all your credits there, like this:\n\nPenguin:\n Kelvin Shadewing, under CC0\n\nIce block:\n Micha\u0142 Banas\n digit1024 on opengameart.org\n under CC-BY-SA 3.0\n\n\n\nGo back to your Python code and import Label from cocos.text. Define a subclass Credits of Layer. In its __init__ function, read the CREDITS file and make a text label at the correct position out of every line in it. class Credits(Layer):\n        def __init__(self):\n                super(Credits, self).__init__()\n                credFile = open(\"CREDITS\",\"r\")\n                creds = credFile.read()\n                creds = creds.split(\"\\n\")\n                for i in range(0, len(creds)):\n                        credLabel = Label(creds[i], font_size=32, anchor_x=\"left\", anchor_y=\"top\")\n                        credLabel.position = 25,500-(i+1)*40\n                        self.add(credLabel)\n\n\n\nGo to your main menu class and add a menu item labelled \"Credits\" that calls the function showCredits when clicked. Define a subclass BackToMainMenuButton of Menu. Make this a menu with one item, labelled \"Back\", that calls the showMainMenu function. This \"menu\", which is more like a button, should be vertically aligned to the bottom and horizontally to the top. class BackToMainMenuButton(Menu):\n        def __init__(self):\n                super(BackToMainMenuButton, self).__init__(\"\")\n                self.menu_valign = BOTTOM\n                self.menu_halign = LEFT\n                menuItems = [(MenuItem(\"Back\", showMainMenu))]\n                self.create_menu(menuItems)\n\n\n\nDefine the function showCredits. It should make a scene out of a MainMenuBgr layer and a Credits layer and run that scene. def showCredits():\n        credSc = Scene(MainMenuBgr())\n        credSc.add(Credits())\n        credSc.add(BackToMainMenuButton())\n        director.run(credSc)"
        },
        {
          "headline":"Check your code.",
          "description":"When you think you finished your code, you should look over all of it again. This can help you notice if something can be optimized, or whether there are some unnecessary lines you forgot to delete. If you followed the example, your entire code should now look as follows:\n\nfrom cocos.director import *\nfrom cocos.menu import *\nfrom cocos.scene import *\nfrom cocos.layer import *\nfrom cocos.sprite import *\nfrom cocos.tiles import *\nfrom cocos.mapcolliders import *\nfrom cocos.actions import *\nfrom cocos.text import Label\n\nimport pyglet.app\nfrom pyglet.window import key\nfrom math import ceil\nfrom random import randint\n\n# \"declaring\" global variables\nkeyboard = 0\nscrMang = 0\n\nclass MainMenuBgr(ColorLayer):\n        def __init__(self):\n                super(MainMenuBgr, self).__init__(0,200,255,255)\nclass MainMenu(Menu):\n        def __init__(self):\n                super(MainMenu, self).__init__(\"\")\n                self.menu_valign = CENTER\n                self.menu_halign = CENTER\n                menuItems = [(MenuItem(\"Start Game\", startGame)), (MenuItem(\"Credits\", showCredits)), (MenuItem(\"Quit\", pyglet.app.exit))]\n                self.create_menu(menuItems)\nclass Credits(Layer):\n        def __init__(self):\n                super(Credits, self).__init__()\n                credFile = open(\"CREDITS\",\"r\")\n                creds = credFile.read()\n                creds = creds.split(\"\\n\")\n                for i in range(0, len(creds)):\n                        credLabel = Label(creds[i], font_size=32, anchor_x=\"left\", anchor_y=\"top\")\n                        credLabel.position = 25,500-(i+1)*40\n                        self.add(credLabel)\nclass BackToMainMenuButton(Menu):\n        def __init__(self):\n                super(BackToMainMenuButton, self).__init__(\"\")\n                self.menu_valign = BOTTOM\n                self.menu_halign = LEFT\n                menuItems = [(MenuItem(\"Back\", showMainMenu))]\n                self.create_menu(menuItems)\nclass FinishMenu(Menu):\n        def __init__(self, text):\n                super(FinishMenu, self).__init__(text)\n                self.menu_valign = CENTER\n                self.menu_halign = CENTER\n                menuItems = [(MenuItem(\"Try again\", startGame)), (MenuItem(\"Quit\", pyglet.app.exit))]\n                self.create_menu(menuItems)\nclass PlatformerController(Action):\n        global keyboard, scrMang\n        on_ground = True\n        MOVE_SPEED = 300\n        JUMP_SPEED = 500\n        GRAVITY = -1200\n        def start(self):\n                self.target.velocity = (0, 0)\n        def step(self, dt):\n                global keyboard, scroller\n                if dt > 0.1: # don't do anything while downtime too big\n                        return\n                vx, vy = self.target.velocity\n                vx = (keyboard[key.RIGHT] - keyboard[key.LEFT]) * self.MOVE_SPEED\n                vy += self.GRAVITY * dt\n                if self.on_ground and keyboard[key.SPACE]:\n                        vy = self.JUMP_SPEED\n                dx = vx * dt\n                dy = vy * dt\n                last = self.target.get_rect()\n                new = last.copy()\n                new.x += dx\n                new.y += dy\n                self.target.velocity = self.target.collision_handler(last, new, vx, vy)\n                self.on_ground = (new.y == last.y)\n                self.target.position = new.center\n                scrMang.set_focus(*new.center)\n                posX, posY = self.target.position\n                if posY < 0:\n                        finishGame(\"Game Over\")\n                        return\n                if posX > 800*3: # level size\n                        finishGame(\"Level Completed\")\n                        return\n\ndef finishGame(text):\n        menuSc = Scene(MainMenuBgr())\n        menuSc.add(FinishMenu(text))\n        director.run(menuSc)\n\ndef showCredits():\n        credSc = Scene(MainMenuBgr())\n        credSc.add(Credits())\n        credSc.add(BackToMainMenuButton())\n        director.run(credSc)\n\ndef generateTilemap():\n        colAmount = ceil(800 / 16)*3 # (screen width / tile size) * 3\n        rowAmount = ceil(600 / 16) # screen height / tile size\n        tileFile = open(\"levelMap.xml\",\"w\")\n        tileFile.write('<resource>\\n<requires file=\"icyTiles.xml\" />\\n<rectmap id=\"solid\" origin=\"0,0,0\" tile_size=\"16x16\">\\n')\n        iceHeight = randint(1,10)\n        for i in range(0,colAmount):\n                tileFile.write('<column>')\n                makeHole = False\n                if randint(0,50) == 10 and i != 0: # don't allow holes at the spawnpoint\n                        makeHole = True\n                for j in range(0,rowAmount):\n                        if makeHole:\n                                tileFile.write('<cell />\\n')\n                        else:\n                                if j <= iceHeight:\n                                        tileFile.write('<cell tile=\"ice\" />\\n')\n                                else:\n                                        tileFile.write('<cell />\\n')\n                iceHeight = randint(iceHeight-5, iceHeight+5)\n                if iceHeight < 0: # limit tiles from going too low\n                        iceHeight = randint(1,5)\n                if iceHeight > rowAmount: # limit tiles from going too high\n                        iceHeight = randint(int(rowAmount/2)-5,int(rowAmount/2)+5)\n                tileFile.write('</column>\\n')\n        tileFile.write('</rectmap>\\n<rectmap id=\"not_solid\" origin = \"0,0,0\" tile_size=\"16x16\">\\n')\n        for i in range(0,colAmount):\n                tileFile.write('<column>')\n                for j in range(0,rowAmount):\n                        tileFile.write('<cell tile=\"sky\" />\\n')\n                tileFile.write('</column>\\n')\n        tileFile.write('</rectmap>\\n</resource>\\n')\n        tileFile.close()\n\ndef startGame():\n        global keyboard, scrMang\n        generateTilemap()\n#\n        fig = Sprite('pingu.png')\n        fig.position = (8, 250)\n        figLayer = ScrollableLayer()\n        figLayer.add(fig)\n#\n        tileLayer = load('levelMap.xml')\n        solidTiles = tileLayer['solid']\n        nsoliTiles = tileLayer['not_solid']\n#\n        keyboard = key.KeyStateHandler()\n        director.window.push_handlers(keyboard)\n#\n        fig.do(PlatformerController())\n        mapcollider = RectMapCollider(velocity_on_bump='slide')\n        fig.collision_handler = make_collision_handler(mapcollider, solidTiles)\n#\n        scrMang = ScrollingManager()\n        scrMang.add(nsoliTiles,z=-1)\n        scrMang.add(solidTiles,z=0)\n        scrMang.add(figLayer,z=1)\n#\n        gameSc = Scene(scrMang)\n        director.run(gameSc)\n\ndef showMainMenu():\n        menuSc = Scene(MainMenuBgr())\n        menuSc.add(MainMenu())\n        director.run(menuSc)\n\nwindow = director.init(caption=\"IcyPlat - a simple platformer\", resizable=True)\nshowMainMenu()\n\n\nThat are 168 lines totally, and 152 lines if you only count the code. This make seem like much, but for such a complex game, this actually is a small amount."
        },
        {
          "headline":"Finished.",
          "description":"Now test the game. When you program something, you have to check whether it works whenever you have implemented something new. Also, you might like to play the game you wrote for some time."
        }
      ]
    },
    {
      "name":"Making a Game with 3D Graphics",
      "steps":[
        {
          "headline":"Choose your tools.",
          "description":"3D graphics are even more complicated than 2D graphics, and require their own libraries. Again, you might find an engine useful for things like collision detection in a game. For most games, you will need or edit 3D models. So you should have at least basic knowledge of a 3D editing program like Blender. This article will show how to make a Pong game in 3D with Panda3D."
        },
        {
          "headline":"Install the tools.",
          "description":"Panda3D can be installed with python3 -m pip install --extra-index-url https://archive.panda3d.org/ panda3d. Blender can either be installed from your system's package manager or from its website."
        },
        {
          "headline":"Make a new directory.",
          "description":"You should keep all files for your game in this folder. This will let you keep your computer tidy and see quickly what files you have for the program."
        },
        {
          "headline":"Create an empty window.",
          "description":"Import a library that's necessary to create the window: from direct.showbase.ShowBase import ShowBase. Also, import everything from the panda3d.core library (with from panda3d.core import *). Define a subclass MyApp of ShowBase. In its initialization function, write loadPrcFileData('', 'window-title 3D Pong')\n This is the function that changes window properties, in this case the window caption to \"3D Pong\". After that, initialize the parent class ShowBase. Create an object app of the class MyApp. Run it to show the window. from direct.showbase.ShowBase import ShowBase\nfrom panda3d.core import *\n\nclass MyApp(ShowBase):\n        def __init__(self):\n                loadPrcFileData('', 'window-title 3D Pong')\n                ShowBase.__init__(self)\n\napp = MyApp()\napp.run()"
        },
        {
          "headline":"Create a 3D model.",
          "description":"You need to create the things you want to show in a 3D game in a 3D editing program first, for example in Blender. You should start with one 3D model, add it, and only then proceed to the other ones. This way, you'll avoid having to repeat a lot of work if you do something wrong at first. Make sure that your 3D models aren't unnecessarily complex, since that can slow down the game. Open Blender. Delete the default cube and add an \"Ico Sphere\" instead. It doesn't appear to be really spherical in Blender itself, but looks close enough to a sphere in the actual game. You could have used the UV sphere, but it is way more complex and so takes more time to render. Warning: Make sure that every object is centered on the point (0, 0, 0) in Blender, and has its origin on the centre of its mass (use Object \u2192 Transform \u2192 Origin to Center of Mass). Otherwise, there will be problems with collision detection later."
        },
        {
          "headline":"Export to a format your 3D library can use.",
          "description":"Like for 2D images, there are different formats for 3D models. You should use one that your 3D library can understand and show. Refer to its documentation if you're not sure which formats it supports. For the example, you need to export the ball model to the Panda3D format. First, save your model as a normal .blend file. This will let you make changes if you need the ball to look differently. Use some reasonable filename you can remember, like ball.blend. Enable export to the DirectX format in Blender. For this, either go to File \u2192 User Preferences... or press Ctrl+Alt+U. In the window that opens, select the category Import-Export. Find DirectX X Format and tick the checkbox to the right of it. Click on Save User Settings and close the window. Export the model to DirectX X format by going to File \u2192 Export \u2192 DirectX (.x), specifying a file name (again, choose something like ball.x and clicking on Export DirectX. Convert DirectX .x to Panda3D .egg. Panda3D already provides a tool to do this. It's called x2egg and the syntax is the following: x2egg input.x output.egg. So to convert your file, type: x2egg ball.x ball.egg."
        },
        {
          "headline":"Load the model into your program.",
          "description":"This is what actually will allow you to see it in the program and do something with it. Set the background colour to black. This will let you better see the models you load. This is done like setting the caption, but with another option: loadPrcFileData('', 'background-color 0 0 0 0')\n Make sure to do this before initializing the window. Go to the end of the __init__ function. Load the model with self.ball = loader.loadModel(\"ball.egg\")\n Note that the model file has to be in the same directory as the program file. Loading the model won't let it appear yet, but it's still necessary. Also, the self. in front of the variable name, which makes it an attribute of the class MyApp, will be useful later, so do this in front of every object you want to change later. Render the loaded model. This is done with ball.reparentTo(self.render). Set the correct position for the ball. It should be at 0, 0, 0 at the beginning. The first coordinate is left/right, the second is forward/backward, the third is down/up. The command for this is self.ball.setPos(0, 0, 0). If you don't see anything yet, this is normal. Try moving the mouse up while holding its right button pressed. Then you should see it. This is because the camera is also at 0, 0, 0 \u2014 inside the ball \u2014 so you don't see it. The right mouse button moves the camera forward and backward."
        },
        {
          "headline":"Set the camera position.",
          "description":"The camera should be at a position where everything can be seen well. Since this is not necessarily the case by default, and because defaults can vary from platform to platform in the same software, you should set the camera position explicitly. First, you need to disable the mouse controls, else Panda3D refuses to set the camera to another position in the program. Then, you can actually set the camera position. Your code should now look as follows:\n\nfrom direct.showbase.ShowBase import ShowBase\nfrom panda3d.core import *\n\nclass MyApp(ShowBase):\n        def __init__(self):\n#               Initialize the window\n                loadPrcFileData('', 'window-title 3D Pong')\n                loadPrcFileData('', 'background-color 0 0 0 0')\n                ShowBase.__init__(self)\n#               Load ball model\n                self.ball = loader.loadModel(\"ball.egg\")\n                self.ball.reparentTo(self.render)\n                self.ball.setPos(0, 0, 0)\n#               Set correct camera position\n                self.disableMouse()\n                camera.setPos(0,-30,0)\n\napp = MyApp()\napp.run()"
        },
        {
          "headline":"Set up the rest of the scene.",
          "description":"When making and loading one model works, you can proceed to make and add the others you need for your scene. Add the walls and bats. Follow the steps described for the ball, except that you don't have to enable the DirectX exporter again. Although there are four walls and two bats, you only need one model of both. Make the wall a thin rectangle that covers the entire Blender \"floor\" and the bat a thin square that's around 2 Blender units high. You'll have to set the positions, rotations and scales manually in the code, so that the ends of the walls touch each other to form a closed shape. You can try to find the correct numbers yourself, or look in the code below, which belongs into the __init__ function under where the ball model is loaded. Also, you have to set the camera closer to the user, to -60 instead of -30. #               Load walls models\n                wallLeft = loader.loadModel(\"wall.egg\"); wallLeft.reparentTo(self.render)\n                wallLeft.setPosHprScale(-15,0,0, 0,0,90, 2,2,1)\n                wallRight = loader.loadModel(\"wall.egg\"); wallRight.reparentTo(self.render)\n                wallRight.setPosHprScale(15,0,0, 0,0,90, 2,2,1)\n                wallBottom = loader.loadModel(\"wall.egg\"); wallBottom.reparentTo(self.render)\n                wallBottom.setPosHprScale(0,0,15, 0,0,0, 2,2,1)\n                wallTop = loader.loadModel(\"wall.egg\"); wallTop.reparentTo(self.render)\n                wallTop.setPosHprScale(0,0,-15, 0,0,0, 2,2,1)\n#               Load bat models\n                self.batPlay = loader.loadModel(\"bat.egg\"); batPlay.reparentTo(self.render)\n                self.batPlay.setPos(-5,-15,-5)\n                self.batPlay.setScale(3,1,3)\n                self.batOpp = loader.loadModel(\"bat.egg\"); batOpp.reparentTo(self.render)\n                self.batOpp.setPos(5,15,-5)\n                self.batOpp.setScale(3,1,3)"
        },
        {
          "headline":"Add lighting.",
          "description":"Now, all objects are present, but it doesn't quite look natural and it's hard to see depth. This can be fixed with lighting. Note that the lights themselves will not be visible and that there are different types of lights. The ones you need for the example game are:\nPoint lights. They emit lights in all directions, like an infinitely small lightbulb. Since they light different objects different because of direction and distance, they will create shadows which will make the scene look more natural. Ambient lights. They don't really have a direction or position, they just light the entire scene the same way. This can't help depth perception, but it makes sure that everything can be seen well. Add the lights with the following code:\n\n#               Lighting\n                alight = AmbientLight('alight')\n                alight.setColor(VBase4(0.1, 0.1, 0.1, 1))\n                alnp = render.attachNewNode(alight)\n                render.setLight(alnp)\n                plight = PointLight('plight')\n                plight.setColor(VBase4(0.9, 0.9, 0.9, 1))\n                plnp = render.attachNewNode(plight)\n                plnp.setPos(0,-16,0)\n                render.setLight(plnp)"
        },
        {
          "headline":"Add controls.",
          "description":"As in other types of games, the player should be able to interact with the game world in some way. Like in 2D games, a common way to do this in 3D games is by making a figure do something when the correct keys are pressed. For this program, you should move the bat when a key is pressed. When a key is pressed, the event is called the same as the key. When a key is held down, this results in a series of events called like the key with -repeat at the end. Make the program call a function when a key is pressed. This is done with the self.accept function. So, for example, calling a function moveLeft when the key a is pressed would be done with self.accept(\"a\", moveLeft). Write the following code into your __init__ function: \n\n#               Move when key pressed\n                self.accept(\"a\", self.moveLeft)\n                self.accept(\"a-repeat\", self.moveLeft)\n                self.accept(\"d\", self.moveRight)\n                self.accept(\"d-repeat\", self.moveRight)\n                self.accept(\"w\", self.moveUp)\n                self.accept(\"w-repeat\", self.moveUp)\n                self.accept(\"s\", self.moveDown)\n                self.accept(\"s-repeat\", self.moveDown)\n\n\n\nDefine the functions that are called by the events. They will move the player's bat appropriately. Make sure that the functions are still in the class MyApp. def moveLeft(self):\n                self.batPlay.setX(self.batPlay.getX()-1)\n        def moveRight(self):\n                self.batPlay.setX(self.batPlay.getX()+1)\n        def moveUp(self):\n                self.batPlay.setZ(self.batPlay.getZ()+1)\n        def moveDown(self):\n                self.batPlay.setZ(self.batPlay.getZ()-1)"
        },
        {
          "headline":"Add collision detection.",
          "description":"Collision detection allows you to notice if two objects are inside of each other, and take the correct measures. You can use it, for example, to prevent the player from going through a wall or to make something that is thrown bounce off when it hits the floor. First, you should do the collision detection for the bats, because you can test it now. You will add the collision detection for the ball later, since it requires different actions. Add a collision traverser. This is the prerequisite for any collision detection in Panda3D and is done withbase.cTrav = CollisionTraverser()\nWhile implementing the collision detection, it is useful to see whether a collision was noticed. Make the collisions visible with base.cTrav.showCollisions(render)\n\n\nCreate a notifier. As its name says, this object will notify the program that some objects collided or are still colliding. You could also make it notify that some objects are no longer colliding, but you don't need it for this game. self.notifier = CollisionHandlerEvent()\n                self.notifier.addInPattern(\"%fn-in-%in\")\n                self.notifier.addAgainPattern(\"%fn-again-%in\")\n\n\n\nMake the program call a function when two objects collide. This is done the same way as with the key presses. For example, if the player's bat collides with the left wall, the event is called \"batPlay-in-wallLeft\". So calling a function blockCollision would be done with self.accept(\"batPlay-in-wallLeft\", self.blockCollision). Set up collision boxes for all the objects you want to detect collisions of. For now, this means all the walls and the two bats. Note that you have to add the line base.cTrav.addCollider(batPlayColl, self.notifier) to every object that can collide with something (the bats in this case), while every object with a collision shape can automatically be collided into. The collision box takes four arguments to be created: the position relative to the centre of the object it applies to, and the scale in x, y and z direction relative to that object. For example:\n\n                batPlayColl = self.batPlay.attachNewNode(CollisionNode(\"batPlay\"))\n                batPlayColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                batPlayColl.show()\n\n\n\nDefine the function for the collision events. Since the behaviour is basically the same in all the cases, you should only define one function that handles all these collisions between a bat and a wall. It should move the bat back to a position where it doesn't collide with the wall. Ideally, that would be handled by setting the position of entry.getFromNodePath(), but that doesn't work, so you have to treat the operations of both bats as separate cases. {{greenbox: Tip: The collision boxes make the game look a bit strange. But while not all collisions are implemented and work flawlessly, it's best to leave them there. After that, you can make them invisible by removing the line base.cTrav.showCollisions(render) and all the lines are the name of a collision shape with .show() at the end. Your entire code should now look like this:\n\nfrom direct.showbase.ShowBase import ShowBase\nfrom panda3d.core import *\n\n\nclass MyApp(ShowBase):\n        def __init__(self):\n#               Initialize the window\n                loadPrcFileData('', 'window-title 3D Pong')\n                loadPrcFileData('', 'background-color 0 0 0 0')\n                ShowBase.__init__(self)\n#               Initialize collision detection\n                base.cTrav = CollisionTraverser()\n                base.cTrav.showCollisions(render)\n                self.notifier = CollisionHandlerEvent()\n                self.notifier.addInPattern(\"%fn-in-%in\")\n                self.notifier.addAgainPattern(\"%fn-again-%in\")\n                self.accept(\"batPlay-in-wallLeft\", self.blockCollision)\n                self.accept(\"batPlay-again-wallLeft\", self.blockCollision)\n                self.accept(\"batPlay-in-wallRight\", self.blockCollision)\n                self.accept(\"batPlay-again-wallRight\", self.blockCollision)\n                self.accept(\"batPlay-in-wallBottom\", self.blockCollision)\n                self.accept(\"batPlay-again-wallBottom\", self.blockCollision)\n                self.accept(\"batPlay-in-wallTop\", self.blockCollision)\n                self.accept(\"batPlay-again-wallTop\", self.blockCollision)\n                self.accept(\"batOpp-in-wallLeft\", self.blockCollision)\n                self.accept(\"batOpp-again-wallLeft\", self.blockCollision)\n                self.accept(\"batOpp-in-wallRight\", self.blockCollision)\n                self.accept(\"batOpp-again-wallRight\", self.blockCollision)\n                self.accept(\"batOpp-in-wallBottom\", self.blockCollision)\n                self.accept(\"batOpp-again-wallBottom\", self.blockCollision)\n                self.accept(\"batOpp-in-wallTop\", self.blockCollision)\n                self.accept(\"batOpp-again-wallTop\", self.blockCollision)\n#               Load ball model\n                self.ball = loader.loadModel(\"ball.egg\")\n                self.ball.reparentTo(self.render)\n                self.ball.setPos(0, 0, 0)\n#               Load walls models and define their collision boxes\n                wallLeft = loader.loadModel(\"wall.egg\"); wallLeft.reparentTo(self.render)\n                wallLeft.setPosHprScale(-15,0,0, 0,0,90, 2,2,1)\n                wallLeftColl = wallLeft.attachNewNode(CollisionNode(\"wallLeft\"))\n                wallLeftColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallLeftColl.show()\n                wallRight = loader.loadModel(\"wall.egg\"); wallRight.reparentTo(self.render)\n                wallRight.setPosHprScale(15,0,0, 0,0,90, 2,2,1)\n                wallRightColl = wallRight.attachNewNode(CollisionNode(\"wallRight\"))\n                wallRightColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallRightColl.show()\n                wallBottom = loader.loadModel(\"wall.egg\"); wallBottom.reparentTo(self.render)\n                wallBottom.setPosHprScale(0,0,15, 0,0,0, 2,2,1)\n                wallBottomColl = wallBottom.attachNewNode(CollisionNode(\"wallBottom\"))\n                wallBottomColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallBottomColl.show()\n                wallTop = loader.loadModel(\"wall.egg\"); wallTop.reparentTo(self.render)\n                wallTop.setPosHprScale(0,0,-15, 0,0,0, 2,2,1)\n                wallTopColl = wallTop.attachNewNode(CollisionNode(\"wallTop\"))\n                wallTopColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallTopColl.show()\n#               Load bat models\n                self.batPlay = loader.loadModel(\"bat.egg\"); self.batPlay.reparentTo(self.render)\n                self.batPlay.setScale(3,1,3)\n                self.batPlay.setPos(-5,-15,-5)\n                batPlayColl = self.batPlay.attachNewNode(CollisionNode(\"batPlay\"))\n                batPlayColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                batPlayColl.show()\n                base.cTrav.addCollider(batPlayColl, self.notifier)\n                self.batOpp = loader.loadModel(\"bat.egg\"); self.batOpp.reparentTo(self.render)\n                self.batOpp.setPos(5,15,-5)\n                self.batOpp.setScale(3,1,3)\n                batOppColl = self.batOpp.attachNewNode(CollisionNode(\"batOpp\"))\n                batOppColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                batOppColl.show()\n                base.cTrav.addCollider(batOppColl, self.notifier)\n#               Set correct camera position\n#               self.disableMouse()\n                camera.setPos(0,-60,0)\n#               Lighting\n                alight = AmbientLight('alight')\n                alight.setColor(VBase4(0.1, 0.1, 0.1, 1))\n                alnp = render.attachNewNode(alight)\n                render.setLight(alnp)\n                plight = PointLight('plight')\n                plight.setColor(VBase4(0.9, 0.9, 0.9, 1))\n                plnp = render.attachNewNode(plight)\n                plnp.setPos(0,-16,0)\n                render.setLight(plnp)\n#               Move when key pressed\n                self.accept(\"a\", self.moveLeft)\n                self.accept(\"a-repeat\", self.moveLeft)\n                self.accept(\"d\", self.moveRight)\n                self.accept(\"d-repeat\", self.moveRight)\n                self.accept(\"w\", self.moveUp)\n                self.accept(\"w-repeat\", self.moveUp)\n                self.accept(\"s\", self.moveDown)\n                self.accept(\"s-repeat\", self.moveDown)\n        def moveLeft(self):\n                self.batPlay.setX(self.batPlay.getX()-1)\n        def moveRight(self):\n                self.batPlay.setX(self.batPlay.getX()+1)\n        def moveUp(self):\n                self.batPlay.setZ(self.batPlay.getZ()+1)\n        def moveDown(self):\n                self.batPlay.setZ(self.batPlay.getZ()-1)\n        def blockCollision(self, entry):\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batPlay\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batPlay.setX(-15+entry.getIntoNodePath().getSx()+self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batPlay.setX(15-entry.getIntoNodePath().getSx()-self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\n                                self.batPlay.setZ(15-entry.getIntoNodePath().getSz()-self.batPlay.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batPlay.setZ(-15+entry.getIntoNodePath().getSz()+self.batPlay.getSz())\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batOpp\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batOpp.setX(-15+entry.getIntoNodePath().getSx()+self.batOpp.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batOpp.setX(15-entry.getIntoNodePath().getSx()-self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\nself.batPlay.setZ(15-entry.getIntoNodePath().getSz()-self.batPlay.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batPlay.setZ(-15+entry.getIntoNodePath().getSz()+self.batPlay.getSz())\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batOpp\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batOpp.setX(-15+entry.getIntoNodePath().getSx()+self.batOpp.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batOpp.setX(15-entry.getIntoNodePath().getSx()-self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\n                                self.batPlay.setZ(10-entry.getIntoNodePath().getSz()-self.batPlay.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batPlay.setZ(-20+entry.getIntoNodePath().getSz()+self.batPlay.getSz())\n\napp = MyApp()\napp.run()"
        },
        {
          "headline":"Add movement.",
          "description":"Not only should the player see some response when they press a key, some objects should also move on their own: this can be used to demand a reaction from the player, or just as nice background detail. Make the ball move. It will fly through the walls for now, but you'll fix that in the next step. Import the functions randint and randrange from the random library. Also, import Task from direct.task. Calculate the speed the ball should have at the beginning. Go to the end of the __init__ function for this. Create a vector of 3 random integers. Note that the y speed is always the same, just either negative or positive. Normalize that vector, i. e. change its components so that their relation is kept, but the vector's total length is 1. Divide that normalized vector by 5 so that the ball doesn't fly too fast. #               Make the ball move\n                self.ballSpeed = VBase3(randint(-10,10),randrange(-1,1,2),randint(-10,10))\n                self.ballSpeed.normalize()\n                self.ballSpeed /= 5\n\n\n\nCreate a task. In Panda3D, a task means calling a function every frame. Write following code under the speed calculations:self.taskMgr.add(self.updateBallPos, \"UpdateBallPos\")\n\n\nDefine the task function. The function should simply add the speed to the ball position. Then, it should return Task.cont, which makes the function being called again next frame. def updateBallPos(self, task):\n                self.ball.setPos(self.ball.getPos()+self.ballSpeed)\n                return Task.cont"
        },
        {
          "headline":"Add collision detection for the moving objects as well.",
          "description":"Pay attention to fast-moving objects: they might require a special kind of collision detection that also looks at the previous frames to determine whether the objects collided at any time, even if it was too fast to happen in any frame. You should make the ball bounce off whenever it collides with something. This will prevent it from flying through the walls or bats. Enable fluid collision detection. For fast-moving objects like the ball in this game, there is a problem with normal collision detection: If the object is in front of what it will collide into in one frame, and already behind it in the next frame, the collision isn't detected. But it's detect such collisions with some adjustments: go to where you initialized the collision traverser and add the line base.cTrav.setRespectPrevTransform(True)\nThen, go to updateBallPos and replace setPos with setFluidPos. Accept ball collision events. Your program should notice collisions between the ball and the walls or the bat. Don't add the again events this time, since you should make sure that the ball only changes direction once \u2014 if it changes direction two times, it just continues flying through the wall or bat. Define the bounceOff function that is called every time the ball collides. To reverse direction, set it to its negative. Use whatever direction the ball was going to escape in: for example, if it collides with the left or right wall, reverse the x-direction. def bounceOff(self, entry):\n                if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\" or str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                        self.ballSpeed[0] = -self.ballSpeed[0]\n                if str(entry.getIntoNodePath()) == \"render/bat.egg/batPlay\" or str(entry.getIntoNodePath()) == \"render/bat.egg/batOpp\":\n                        self.ballSpeed[1] = -self.ballSpeed[1]\n                if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\" or str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                        self.ballSpeed[2] = -self.ballSpeed[2]\n\n\n\nAdjust inappropriate values. Now you can test what it's like to play the game, although the opponent will miss the ball with very high probability. But you can test whether you can see the ball well and hit it yourself. You could move the camera back to -75 and the bats to \u00b125 for an easier gameplay. You could also make the ball bigger so that it's easier to see in which direction it is moving and how close it is. You can make the walls a bit longer (scale 3 instead of 2 in Y-direction) so that the ball can't fly outside the field of view before getting behind the bat."
        },
        {
          "headline":"Define the opponent's behaviour.",
          "description":"If your game has any sort of opponent, you will have to program their behaviour because the player is very unlikely to have a real opponent. Surely, there are network multiplayer games where the player has to play against another player on another computer, but they're very hard to program and many of them also have a singleplayer option. Add another task. Make this one call a function named directOpponent. Define the function directOpponent. Just directing the bat to follow the ball in X/Z direction is easy. The problem is that the opponent also has to make mistakes, so that the player has a chance to win. This can be done with the correct amount of randomness. In the function below, the opponent's bat either moves in the correct direction or in the opposite direction. This makes it possible to miss the ball sometimes. Make the positive number higher if you want the opponent to hit the ball more often, and the negative number lower if you want it to miss the ball more often. If you do both, the effects will cancel each other out. def directOpponent(self, task):\n                dirX = randint(-2,4)*(self.ball.getX() - self.batOpp.getX())\n                dirZ = randint(-2,4)*(self.ball.getZ() - self.batOpp.getZ())\n                self.batOpp.setX(self.batOpp.getX() + copysign(1/7, dirX))\n                self.batOpp.setZ(self.batOpp.getZ() + copysign(1/7, dirZ))\n                return Task.cont\n\n\n\nPlay the game. While the ball still is gone forever when either the player or the opponent miss, it's already possible to test the gameplay and adjust something if necessary. Make the collision boxes invisible now. There are many collisions in this game, and the constant flashing of the boxes can distract and annoy. So remove the line base.cTrav.showCollisions(render) and all the lines are the name of a collision shape with .show() at the end, like for example wallLeftColl.show()."
        },
        {
          "headline":"Establish limits.",
          "description":"If, except of other objects to collide with, the objects have no limits of where they can move, this can cause problems. If, for example, the player throws a ball and it never comes back, they will be quite annoyed about it. In the example, the program should detect when the ball is out of the field. If this happens, the program should put it back to (0,0,0) and give a point to the player that didn't miss. Import OnscreenText from direct.gui.OnscreenText. Define the score as a list. It should have two items that are both set to 0 at the beginning. Display the text as OnscreenText. Positioning is different here: the first number is left/right, and the second is down/up. Both have half the screen as 1 unit. fg sets the colour of the text. #               Count the scores\n                self.scores = [0,0]\n                self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n\n\n\nAdd two if-statements to the updateBallPos function. They should check whether the ball is beyond 26 or -26, and if that's the case, put the ball back to (0,0,0) and increment the appropriate score (either the player's or the opponent's). def updateBallPos(self, task):\n                self.ball.setFluidPos(self.ball.getPos()+self.ballSpeed)\n                if self.ball.getY() > 26:\n                        self.scores[0] += 1\n                        self.ball.setPos(0,0,0)\n                        self.scoreCount.destroy() # destroy last text before adding new\n                        self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n                if self.ball.getY() < -26:\n                        self.scores[1] += 1\n                        self.ball.setPos(0,0,0)\n                        self.scoreCount.destroy()\n                        self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n                return Task.cont"
        },
        {
          "headline":"Check your code.",
          "description":"If you wrote the game in the example, your entire code should now look like this:\n\nfrom direct.showbase.ShowBase import ShowBase\nfrom direct.task import Task\nfrom panda3d.core import *\nfrom direct.gui.OnscreenText import OnscreenText\nfrom random import randint, randrange\nfrom math import copysign\n\nclass MyApp(ShowBase):\n        def __init__(self):\n#               Initialize the window\n                loadPrcFileData('', 'window-title 3D Pong')\n                loadPrcFileData('', 'background-color 0 0 0 0')\n                ShowBase.__init__(self)\n#               Initialize collision detection\n                base.cTrav = CollisionTraverser()\n                base.cTrav.setRespectPrevTransform(True)\n                self.notifier = CollisionHandlerEvent()\n                self.notifier.addInPattern(\"%fn-in-%in\")\n                self.notifier.addAgainPattern(\"%fn-again-%in\")\n                self.accept(\"batPlay-in-wallLeft\", self.blockCollision)\n                self.accept(\"batPlay-again-wallLeft\", self.blockCollision)\n                self.accept(\"batPlay-in-wallRight\", self.blockCollision)\n                self.accept(\"batPlay-again-wallRight\", self.blockCollision)\n                self.accept(\"batPlay-in-wallBottom\", self.blockCollision)\n                self.accept(\"batPlay-again-wallBottom\", self.blockCollision)\n                self.accept(\"batPlay-in-wallTop\", self.blockCollision)\n                self.accept(\"batPlay-again-wallTop\", self.blockCollision)\n                self.accept(\"batOpp-in-wallLeft\", self.blockCollision)\n                self.accept(\"batOpp-again-wallLeft\", self.blockCollision)\n                self.accept(\"batOpp-in-wallRight\", self.blockCollision)\n                self.accept(\"batOpp-again-wallRight\", self.blockCollision)\n                self.accept(\"batOpp-in-wallBottom\", self.blockCollision)\n                self.accept(\"batOpp-again-wallBottom\", self.blockCollision)\n                self.accept(\"batOpp-in-wallTop\", self.blockCollision)\n                self.accept(\"batOpp-again-wallTop\", self.blockCollision)\n                self.accept(\"ball-in-wallLeft\", self.bounceOff)\n                self.accept(\"ball-in-wallRight\", self.bounceOff)\n                self.accept(\"ball-in-wallBottom\", self.bounceOff)\n                self.accept(\"ball-in-wallTop\", self.bounceOff)\n                self.accept(\"ball-in-batPlay\", self.bounceOff)\n                self.accept(\"ball-in-batOpp\", self.bounceOff)\n#               Load ball model\n                self.ball = loader.loadModel(\"ball.egg\")\n                self.ball.reparentTo(self.render)\n                self.ball.setPos(0, 0, 0)\n                ballColl = self.ball.attachNewNode(CollisionNode(\"ball\"))\n                ballColl.node().addSolid(CollisionSphere(0, 0, 0, 0.25))\n                ballColl.show()\n                base.cTrav.addCollider(ballColl, self.notifier)\n#               Load walls models and define their collision boxes\n                wallLeft = loader.loadModel(\"wall.egg\"); wallLeft.reparentTo(self.render)\n                wallLeft.setPosHprScale(-15,0,0, 0,0,90, 2,3,1)\n                wallLeftColl = wallLeft.attachNewNode(CollisionNode(\"wallLeft\"))\n                wallLeftColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallRight = loader.loadModel(\"wall.egg\"); wallRight.reparentTo(self.render)\n                wallRight.setPosHprScale(15,0,0, 0,0,90, 2,3,1)\n                wallRightColl = wallRight.attachNewNode(CollisionNode(\"wallRight\"))\n                wallRightColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallBottom = loader.loadModel(\"wall.egg\"); wallBottom.reparentTo(self.render)\n                wallBottom.setPosHprScale(0,0,15, 0,0,0, 2,3,1)\n                wallBottomColl = wallBottom.attachNewNode(CollisionNode(\"wallBottom\"))\n                wallBottomColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallTop = loader.loadModel(\"wall.egg\"); wallTop.reparentTo(self.render)\n                wallTop.setPosHprScale(0,0,-15, 0,0,0, 2,3,1)\n                wallTopColl = wallTop.attachNewNode(CollisionNode(\"wallTop\"))\n                wallTopColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n#               Load bat models\n                self.batPlay = loader.loadModel(\"bat.egg\"); self.batPlay.reparentTo(self.render)\n                self.batPlay.setScale(3,1,3)\n                self.batPlay.setPos(-5,-25,-5)\n                batPlayColl = self.batPlay.attachNewNode(CollisionNode(\"batPlay\"))\n                batPlayColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                base.cTrav.addCollider(batPlayColl, self.notifier)\n                self.batOpp = loader.loadModel(\"bat.egg\"); self.batOpp.reparentTo(self.render)\n                self.batOpp.setPos(5,25,-5)\n                self.batOpp.setScale(3,1,3)\n                batOppColl = self.batOpp.attachNewNode(CollisionNode(\"batOpp\"))\n                batOppColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                base.cTrav.addCollider(batOppColl, self.notifier)\n#               Set correct camera position\n                self.disableMouse()\n                camera.setPos(0,-75,0)\n#               Lighting\n                alight = AmbientLight('alight')\n                alight.setColor(VBase4(0.1, 0.1, 0.1, 1))\n                alnp = render.attachNewNode(alight)\n                render.setLight(alnp)\n                plight = PointLight('plight')\n                plight.setColor(VBase4(0.9, 0.9, 0.9, 1))\n                plnp = render.attachNewNode(plight)\n                plnp.setPos(0,-16,0)\n                render.setLight(plnp)\n#               Move when key pressed\n                self.accept(\"a\", self.moveLeft)\n                self.accept(\"a-repeat\", self.moveLeft)\n                self.accept(\"d\", self.moveRight)\n                self.accept(\"d-repeat\", self.moveRight)\n                self.accept(\"w\", self.moveUp)\n                self.accept(\"w-repeat\", self.moveUp)\n                self.accept(\"s\", self.moveDown)\n                self.accept(\"s-repeat\", self.moveDown)\n#               Make the ball move\n                self.ballSpeed = VBase3(randint(-10,10),randrange(-1,2,2)*8,randint(-10,10))\n                self.ballSpeed.normalize()\n                self.ballSpeed /= 7\n                self.taskMgr.add(self.updateBallPos, \"UpdateBallPos\")\n                self.taskMgr.add(self.directOpponent, \"DirectOpponent\")\n#               Count the scores\n                self.scores = [0,0]\n                self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n        def moveLeft(self):\n                self.batPlay.setX(self.batPlay.getX()-1)\n        def moveRight(self):\n                self.batPlay.setX(self.batPlay.getX()+1)\n        def moveUp(self):\n                self.batPlay.setZ(self.batPlay.getZ()+1)\n        def moveDown(self):\n                self.batPlay.setZ(self.batPlay.getZ()-1)\n        def blockCollision(self, entry):\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batPlay\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batPlay.setX(-15+entry.getIntoNodePath().getSx()+self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batPlay.setX(15-entry.getIntoNodePath().getSx()-self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\n                                self.batPlay.setZ(15-entry.getIntoNodePath().getSz()-self.batPlay.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batPlay.setZ(-15+entry.getIntoNodePath().getSz()+self.batPlay.getSz())\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batOpp\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batOpp.setX(-15+entry.getIntoNodePath().getSx()+self.batOpp.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batOpp.setX(15-entry.getIntoNodePath().getSx()-self.batOpp.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\n                                self.batOpp.setZ(15-entry.getIntoNodePath().getSz()-self.batOpp.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batOpp.setZ(-15+entry.getIntoNodePath().getSz()+self.batOpp.getSz())\n        def bounceOff(self, entry):\n                if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\" or str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                        self.ballSpeed[0] = -self.ballSpeed[0]\n                if str(entry.getIntoNodePath()) == \"render/bat.egg/batPlay\" or str(entry.getIntoNodePath()) == \"render/bat.egg/batOpp\":\n                        self.ballSpeed[1] = -self.ballSpeed[1]\n                if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\" or str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                        self.ballSpeed[2] = -self.ballSpeed[2]\n        def updateBallPos(self, task):\n                self.ball.setFluidPos(self.ball.getPos()+self.ballSpeed)\n                if self.ball.getY() > 26:\n                        self.scores[0] += 1\n                        self.ball.setPos(0,0,0)\n                        self.scoreCount.destroy() # destroy last text before adding new\n                        self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n                if self.ball.getY() < -26:\n                        self.scores[1] += 1\n                        self.ball.setPos(0,0,0)\n                        self.scoreCount.destroy()\n                        self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n                return Task.cont\n        def directOpponent(self, task):\n                dirX = randint(-2,4)*(self.ball.getX() - self.batOpp.getX())\n                dirZ = randint(-2,4)*(self.ball.getZ() - self.batOpp.getZ())\n                self.batOpp.setX(self.batOpp.getX() + copysign(1/7, dirX))\n                self.batOpp.setZ(self.batOpp.getZ() + copysign(1/7, dirZ))\n                return Task.cont\n\napp = MyApp()\napp.run()\n\n\nThat are 166 lines totally, and 152 lines of pure code. 3D games are very complex, so this is a normal amount of lines for such a game."
        },
        {
          "headline":"Finished.",
          "description":"This game has no possibility to win or lose at some point yet, and there is no possibility to restart it without restarting the program. Such features would make your program even more complex, so if you want more practice, try to implement them. Anyway, you should play the game for some time to check whether everything works as it should, and maybe to actually have fun with the game you wrote."
        }
      ]
    },
    {
      "name":"Publishing the Game",
      "steps":[
        {
          "headline":"Write down the dependencies.",
          "description":"Anyone who uses another computer will not have the same software and libraries installed as you. So you have to make sure that every user that installs your program also installs everything the program needs to work. You don't have to write down all dependencies of all dependencies of all dependencies and so on, because the list could become very long this way, but you should at least write the dependencies of your package and their dependencies."
        },
        {
          "headline":"Check the licenses.",
          "description":"This applies media, like images, 3D models or music, libraries and frameworks you used for your program, and anything used in your program that you didn't write yourself. Often there are some conditions, like having to credit the author or share modifications of the media under the same license. Sometimes it's also forbidden to use it for commercial purposes, like a game which you'll sell for money. If you have to credit the author, make sure to do it in a well-visible place, like a \"Credits\" tab in your game. There is also media with copyright claimed and no license specified, sometimes with some text like \"All rights reserved\". If that's the case, you must get explicit permission from the author before including it in your game. Libraries usually are released under some license that allows using them as libraries. A notable exception is the GPL without linking exception: such a license only allows to use it in a program with certain licenses. And you should always read at least the basic points of the license to make sure whatever you're doing with the media or library is allowed. Warning: Using media or libraries in a way that the license doesn't permit in a game that you publish can get you into serious legal trouble. So either ask the author or avoid the piece of media altogether if you are unsure about whether your usage is allowed."
        },
        {
          "headline":"Decide on the conditions you want to publish your game on.",
          "description":"While you have to be careful about the restrictions that your external media sets, you usually can decide on the license of your code yourself. You can use some very permissive license, like the CC0. You can use a license that allows distribution and modification under some conditions, like the BSD license or the GPL. Or you could make your software proprietary, meaning that nobody is allowed to distribute or modify it without your permission. Decide whether you want to sell your software. Although it is possible to make money by selling software, it is quite unlikely that people will buy your first software that usually has few features and nothing special. Also, if a gratis program doesn't work, people who downloaded it will just be disappointed; if they paid for it, however, they'll demand their money back, causing more problems for both you and the users. So consider making your first few programs available for free."
        },
        {
          "headline":"Decide how you want to publish your game.",
          "description":"Every method has some advantages and disadvantages, so you have to decide yourself. Publishing it on a website: If you have a website, you can upload your game on it. Make sure to give the visitors instructions on how to install not only the software, but also the dependencies. The disadvantage of this method is that the user has install the dependencies manually, which may be too hard for some people who just want to play the game, and a quite boring task. Making a package for a package manager: there are different package managers, like apt, yum or homebrew. They all have different, specific package formats. Refer to the reference for the respective format. The good thing about package manager packages is that they will automatically install all dependencies if you configure them correctly. So the user only has to install your package and can then play the game. The problem is that there are many different package managers on different platforms, so you will have to put some work into providing packages for all the most common ones."
        },
        {
          "headline":"Direct attention to your program.",
          "description":"Consider uploading your program to a major package repository, like the ones Ubuntu and Debian maintain. This will allow users to install it very easily. Also, post in appropriate forums, like the projects section of GameDev or a part of tigSource. But don't be disappointed if your first games don't become famous. Move on, if you have some idea that many people like and code it, your game can become well-known."
        }
      ]
    }
  ],
  "text":" Making a Text-Based Game Choose a programming language. All programming languages are different, so you will have to decide which one to use to write your game. Every major programming language supports text input, text output and if-constructions (the main things you need for a simple text-based game), so you can decide yourself. Here are some factors to consider:\nField of application: some programming languages, like JavaScript, are designed to be used for web sites, others, like Python, C or C++, are designed to run on a computer. Some languages have one specific purpose, like R, which is mainly used for statistical analysis. For your game, you should use a language with a broader application field (Python, C, C++, JavaScript, many others). Ease of use: although writing a program should be easy enough after some practice in any normal programming language (i. e. not one specifically designed to be confusing and unusable like Malbolge), some are friendlier to beginners than others. Java and C, for example, require the programmer to understand more programming concepts than Python. Also, Python error messages are easier to understand for a beginner than, for example, C error messages. Platform compatibility: you probably want people on different systems, such as Linux, Mac or Windows, to all be able to play your game. So you shouldn't use a language that is only supported on a few systems, like for example Visual Basic, which is only supported on Windows. This is also a good reason not to code your game in Assembler, which is specific to the system and processor, and is also quite hard to program with. This article will use Python for the examples of a text-based game, but you can look up how the concepts are done in any other programming language. Install the necessary tools. You need something to compile or interpret your program with, and you need something to write/edit it with. If you want to follow the example in this article, you should install Python and learn how to run programs. If you want to, you can set up some IDE or use one that Python provides (it's called IDLE), but you can also just use your favourite text editor that supports plain text. Print some text. The player will want to know what is going on and what they have to do, so you should print some text for them. This is done with the print() function in Python. To try it out, open a new file with the .py extension, enter the following code into it, save and run it:\n\nprint(\"Welcome to the number guessing game!\") print(\"Enter a whole number between between 1 and 1000:\") Introduce some randomness into your game. If nothing is random, the game will be exactly the same every time, and the player will get bored quickly. In this case, a number should be randomly chosen at the start of the program so that the player won't always guess the same number. Since it should remain the same throughout the program, you should store the random number in a variable. Python doesn't provide a random number function in its core. But it has a standard library (this means the user won't have to install anything extra) that does. So go to the beginning of your code (before the print() functions) and type the line import random. Use the random function. It is called randint(), is in the random library which you just imported, and takes the minimal and maximal value the number can have as argument. So go back to the end of your code and enter following line:\n\nrightNum = random.randint(0,1000) Get the player's input. In a game, the player wants to do something or interact with something. In a text-based game, this is possible by entering text. Since the code you entered prints the instruction to enter a number to the player, it should also read the number they enter. This is done with input() in Python 3, and raw_input() in Python 2. You should write in Python 3, as Python 2 will become outdated soon. Add the following line to your code to store the player's input in a variable called number:\n\nuserNum = input() Turn the user's input into a usable data type. Make the player's input a number. Now, this might seem confusing because they just entered a number. But there is a good reason: Python assumes that all input is text, or how it is called in programming, a string. And this text contains the number you want to get. Python provides a function to convert a string that only contains a number to the number inside. Type:\n\nuserNum = int(userNum) Process the user's input. It would be pointless to just ask the player to enter random things. You should actually do something with the information that the user entered. Compare the user's number to the correct number. While the numbers are not the same, it should make the user enter another number. When the numbers match, it should stop getting new input, tell the user that they guessed correctly, and quit the program. This is done with the following code:\n\nwhile userNum != rightNum:\n    userNum = int(input()) Give the player feedback. While you already have processed the input, the user can't see this. You need to actually print the result to the user so they understand what's happening. Surely, you could just tell the user whether their number is right or wrong. But with that approach, the player would have to guess 1000 times in the worst case, which would be very boring. So tell the player whether their number is too small or too big. This will reduce the number of guesses significantly: If, for example, the user guesses 500 first, and is told that it's too big, there are only 500 possible numbers now instead of 1000. This is done with if-constructions, so replace the print(\"Wrong. Try again.\") with one. Be aware that checking whether two numbers are the same is done with == , not with = . = assigns the value right of it to the variable left of it! if userNum < rightNum:\n    print(\"Too small. Try again:\")\nif userNum > rightNum:\n    print(\"Too big. Try again:\") Test your code. As a programmer, you should be sure that your code works in all cases before considering it finished. When programming in python, make sure that you get the indentations correct. Your code should look like this:\n\nimport random\nprint(\"Welcome to the number guessing game!\") print(\"Enter a whole number between 1 and 1000:\")\nrightNum = random.randint(0,1000)\nuserNum = input()\nuserNum = int(userNum)\nwhile userNum != rightNum:\n    if userNum < rightNum:\n        print(\"Too small. Try again:\")\n    if userNum > rightNum:\n        print(\"Too big. Try again:\")\n    userNum = int(input())\nprint(\"You guessed correctly.\") Validate the input. A user shouldn't be able to break your program with simple actions like entering the wrong thing. Validating the input means whether the user entered the correct thing before processing it. Open the game again and try entering anything that's not a number. The game will exit with a ValueError. To avoid this, you should implement a way to check whether the input was a number. Define a function. Since validating the input is quite long, and you have to do it multiple times, you should define a function. It will take no arguments and return a number. First, write def numInput(): at the top of your code, directly under the import random. Get the user's input once. Use the input() function and assign the result to the variable inp. While the user's input is not a number, ask them to enter a number. Checking whether a string is a number is done with the isdigit() functions, which only allows a whole number, so you won't have to check for that separately. When the input is a number, convert it from string to number and return the result. Use the int() function for converting the string to an integer. This will make the conversion in the main code unnecessary, and you should remove it from there. Replace all calls to input() in the main code with calls to numInput(). The code of the numInput() function will look like this:\n\n\ndef numInput():\n    inp = input()\n    while not inp.isdigit():\n        print(\"You were told to enter a whole number! Enter a whole number:\")\n        inp = input()\n    return int(inp) Test the game again. Especially pay attention to whether your input validation works by entering something wrong on purpose. Try entering some text when the program asks you for a number. Now, instead of exiting with an error message, the program will ask you for a number again. Suggest restarting the game when it finishes. This way, the player could play your game for a longer time without having to constantly restart it. Put all code except the import and the function definition into a while-loop. Set True as the condition: this will always be true, so the loop will continue forever. Ask the player whether they want to play again after they guessed the number correctly. Use the print() function. If they answer \"No\", break out of the look. If they answer anything else, continue. Breaking out of a loop is done with the break statement. Move the \"Welcome to the number guessing game\" outside the while loop. The player probably doesn't want to be welcomed every time they play the game. Move the instruction print(\"Welcome to the number guessing game!\" above the while True:, so it will be printed only once, when the user starts the first game. Test the game. You need to be sure that your game still works after implementing new features. Make sure to answer both \"Yes\" and \"No\" at least once to make sure that both options work. Here is what your code should look like:\n\nimport random\n\ndef numInput():\n    inp = input()\n    while not inp.isdigit():\n        print(\"You were told to enter a whole number! Enter a whole number:\")\n        inp = input()\n    return int(inp)\n\nprint(\"Welcome to the number guessing game!\") while True:\n    print(\"Enter a whole number between 1 and 1000:\")\n    rightNum = random.randint(0,1000)\n    userNum = numInput()\n    while userNum != rightNum:\n        if userNum < rightNum:\n            print(\"Too small. Try again:\")\n        if userNum > rightNum:\n            print(\"Too big. Try again:\")\n        userNum = numInput()\n    print(\"You guessed correctly.\") print(\"Do you want to play again? Enter No to quit.\") if input() == \"No\":\n        break Write other text-based games. How about writing a text adventure next? Or a quiz game? Be creative. Tip: It's sometimes helpful to look in the documentation if you're not sure how something is done or how a function is used. The Python 3 documentation is found at https://docs.python.org/3/. Sometimes searching for whatever you want to do on the internet also returns good results. Making a Game with 2D Graphics Choose a library. Making graphics is very complicated, and most programming languages (including Python, C++, C, JavaScript) provide only minimal or even no support for graphics in the core or the standard libraries. So you'll have to use an external library to be able to make graphics, for example Pygame for Python. Even with a graphics library, you'll have to worry a lot about low-level things like how to display a menu, how to check whether the user clicked on it, how to display the tiles, and so on. If you prefer to focus on developing the actual game, and especially if the game you want to make is complex, you should use a game engine library, which implements such things. This article will use Python with Cocos2D to show how to make a simple 2D platformer. Some of the mentioned concepts may not exist in other game engines. Refer to their documentation for more information. Install the library you chose. Cocos2D for Python is simply installed with sudo pip3 install cocos2d. Make a new directory. You will use things like images and sounds in your game. You should keep these things in the same directory as the program, and the directory shouldn't contain anything else so that you can easily see what assets you have in the game. Change into the new directory and create a new code file. It should be named main, with the file extension of your programming language. If you write a large and complex program where it makes sense to have multiple program files, this will show which one is the main one. In this example, this file, which should be called main.py, will contain all your code. But the directory you created will still be useful for other media files. Make a window. This is the basic prerequisite for a game with graphics. You can add the simplest content now, like for example a background colour. Import the necessary cocos2d sub-modules: cocos.director, cocos.scene and cocos.layer. This is done with from subModuleName import *, where subModuleName is the submodule you want to import. The difference between from ... import * and import ... is that you don't have to put the module name in front of everything you use from that module with the former. Define a subclass MainMenuBgr of the ColorLayer. This basically means that any main menu background you create will behave like a color layer with some changes you make. Initialize the cocos director. This will give you a new window. If you don't set some caption, the window will have the same caption as the file name (main.py), which doesn't look very professional. Allow the window to be resized with by setting resizable to True. Define a function showMainMenu. You should put the code for showing the main menu into a function because this will allow you to easily return to the main menu by calling the function again. Create a scene. The scene consists of one layer for now, which is an object of the MainMenuBgr class you defined. Run this scene in the window. from cocos.director import *\nfrom cocos.scene import *\nfrom cocos.layer import *\n\nclass MainMenuBgr(ColorLayer):\n        def __init__(self):\n                super(MainMenu, self).__init__(0,200,255,255)\n\ndef showMainMenu():\n        menuSc = Scene(MainMenuBgr())\n        director.run(menuSc)\n\ndirector.init(caption=\"IcyPlat - a simple platformer\", resizable=True)\nshowMainMenu() Create a main menu. Besides the actual game, you should have an option to close the game. You'll also add credits later, but ignore them for now. A main menu will avoid making entering the game too unexpected.Import necessary modules. You need to import cocos.menu (again with the from instruction) and pyglet.app (this time with import). Define MainMenu as a subclass of Menu. Set the alignment of the main menu. You have to set the vertical and horizontal alignment separately. Create a list of menu items and add create the actual menu. You should have the menu items \"Start Game\" and \"Quit\". Make sure to put every created menu item inside of brackets. A menu item has a label and a callback function for when it's clicked. For the \"Start Game\" item, use the startGame function (you'll write it soon), for the \"Quit\" item, use \"pyglet.app.exit\" (already exists). Create the actual menu by calling self.create_menu(menuItems). Define startGame(). Just put pass into the definition for now, you'll replace that when you write the actual game. Go to the place in your code where you created the menuSc scene, and add a MainMenu object to it. Your entire code should now look as follows:\n\nfrom cocos.director import *\nfrom cocos.menu import *\nfrom cocos.scene import *\nfrom cocos.layer import *\n\nimport pyglet.app\n\nclass MainMenuBgr(ColorLayer):\n        def __init__(self):\n                super(MainMenuBgr, self).__init__(0,200,255,255)\nclass MainMenu(Menu):\n        def __init__(self):\n                super(MainMenu, self).__init__(\"\")\n                self.menu_valign = CENTER\n                self.menu_halign = CENTER\n                menuItems = [(MenuItem(\"Start Game\", startGame)), (MenuItem(\"Quit\", pyglet.app.exit))]\n                self.create_menu(menuItems)\n\ndef startGame():\n        pass\n\ndef showMainMenu():\n        menuSc = Scene(MainMenuBgr())\n        menuSc.add(MainMenu())\n        director.run(menuSc)\ndirector.init(caption=\"IcyPlat - a simple platformer\", resizable=True)\nshowMainMenu() Test your code. It is important to test you code at such an early stage, while it is still short and relatively simple: this way you will know any mistakes in the basic structure, and can fix them before they cause  more problems. The code from the instructions should open a window, captioned \"IcyPlat - a simple platformer\", that you can resize and that has a light blue background. It should have a menu with two items: when you click on \"Start Game\", nothing happens; when you click on \"Quit\", the program quits. Display a sprite in the game. The sprite is like a \"game object\". In a platformer, for example, one should be the main figure that the player can control (in this step, it'll only be displayed however). Things like background decorations or object the player can interact with can also be sprites, but you should only add one first to understand the concept, then you can add whatever else you want. Import the cocos.sprite submodule with the from-import-expression. Find an image. You can't display a sprite if you don't have a picture for it. You can draw one, or you can get one from the internet (watch out for the license, though, if you're planning to publish your game), for example from here (crop the image so you only have one running penguin). Make sure to put your image into the same directory as the program. Create the sprite's layer and the sprite. Create the layer as a new object of the ScrollableLayer class. Create the sprite as a Sprite object and set its position to (8, 250). For reference, the point (0, 0) is in the bottom left corner. This is quite high, but it will make sure that the penguin doesn't get stuck in the ice. Add the sprite to the sprite's layer. Create a new scene out of the sprite's layer and run it. def startGame():\n        figLayer = ScrollableLayer()\n        fig = Sprite('pingu.png')\n        fig.position = (75, 100)\n        figLayer.add(fig)\n#\n        gameSc = Scene(figLayer)\n        director.run(gameSc)\n\n\nYou can run your code now if you want. You will see a small penguin figure (or whatever you drew) on a black background after you click on \"Start Game\". Decide what your landscape will consist of. In most games, your sprites shouldn't just float in the void. They should actually stand on some surface, with something around them. In 2D games, this is often done with a tile set and a tile map. The tile set basically says what kind of surface squares and background squares exist, and what they look like. Create a tile set. The tile set for this game will be very basic: one tile for ice and one tile for sky. The ice tile used in this example is from here, under CC-BY-SA 3.0. Create a tile set picture. That's a picture of all tiles, which have to all be of the same size (edit them if they aren't) and have the size you want to see in the game, next to each other. Save your picture as icyTiles.png. Create the tile set description. That's an XML file. The XML file contains information on how big the tiles are in the tile set picture, which picture to use, and where to find which tile there. Create an XML file named icyTiles.xml with the code below:\n\n<?xml version=\"1.0\"?>\n<resource>\n    <imageatlas size=\"16x16\" file=\"icyTiles.png\">\n        <image id=\"i-ice\" offset=\"0,0\" />\n        <image id=\"i-sky\" offset=\"16,0\" />\n    </imageatlas>\n    <tileset>\n        <tile id=\"ice\"><image ref=\"i-ice\" />\n        </tile>\n        <tile id=\"sky\"><image ref=\"i-sky\" />\n        </tile>\n    </tileset>\n</resource> Make an actual structure out of the elements of your landscape. If you made a tile set, this should be done in the form of a tile map. A tile map is like a map that defines which tile is at which position in your level. In the example, you should define a function to generate tile maps because designing tile maps by hand is very tedious. A more advanced game would usually have some sort of level editor, but for becoming familiar with 2D game development, an algorithm can provide good enough levels. Find out how many rows and columns are needed. For this, divide the screen size by the tile size both horizontally (columns) and vertically (rows). Round the number upwards; you need a function of the math module for that, so add from math import ceil to the imports at the top of your code. Open a file for writing. This will erase all previous content of the file, so choose a name that no file in the directory has yet, like levelMap.xml. Write the opening tags into the file. Generate a tile map according to the algorithm. You use the one in the code below, or you can come up with one on your own. Make sure to import the randint function from the module random: it's required for the code below to work, and whatever you come up with will probably also need random integers. Also, make sure to put sky tiles and ice tiles in different layers: ice is solid, sky is not. Write the closing tags into the file and close the file. def generateTilemap():\n        colAmount = ceil(800 / 16)*3 # (screen width / tile size) * 3\n        rowAmount = ceil(600 / 16) # screen height / tile size\n        tileFile = open(\"levelMap.xml\",\"w\")\n        tileFile.write('<resource>\\n<requires file=\"icyTiles.xml\" />\\n<rectmap id=\"solid\" origin=\"0,0,1\" tile_size=\"16x16\">\\n')\n        iceHeight = randint(1,10)\n        for i in range(0,colAmount):\n                tileFile.write('<column>')\n                makeHole = False\n                if randint(0,50) == 10 and i != 0: # don't allow holes at the spawnpoint\n                        makeHole = True\n                for j in range(0,rowAmount):\n                        if makeHole:\n                                tileFile.write('<cell />\\n')\n                        else:\n                                if j <= iceHeight:\n                                        tileFile.write('<cell tile=\"ice\" />\\n')\n                                else:\n                                        tileFile.write('<cell />\\n')\n                iceHeight = randint(iceHeight-5, iceHeight+5)\n                if iceHeight < 0: # limit tiles from going too low\n                        iceHeight = randint(1,5)\n                if iceHeight > rowAmount: # limit tiles from going too high\n                        iceHeight = randint(int(rowAmount/2)-5,int(rowAmount/2)+5)\n                tileFile.write('</column>\\n')\n        tileFile.write('</rectmap>\\n<rectmap id=\"not_solid\" origin = \"0,0,0\" tile_size=\"16x16\">\\n')\n        for i in range(0,colAmount):\n                tileFile.write('<column>')\n                for j in range(0,rowAmount):\n                        tileFile.write('<cell tile=\"sky\" />\\n')\n                tileFile.write('</column>\\n')\n        tileFile.write('</rectmap>\\n</resource>\\n')\n        tileFile.close() Display the tile map. Import everything from cocos.tiles and then go into the startGame function for that. At the beginning of your startGame function, generate a tile map using the function you defined for that. Create a new scrolling manager. Do this directly under the line where you add the sprite to its layer. Create a new layer containing the tiles, which will be loaded from the levelMap.xml tile map your generateTilemap function generated. Add the non-solid layer, the solid layer and the sprite layer to the scrolling manager, exactly in this order. You can add a z-position if you want. Instead of creating the scene from the sprite layer, create it from the scrolling manager. Your startGame function should now look like this:\n\ndef startGame():\n        generateTilemap()\n#\n        fig = Sprite('pingu.png')\n        fig.position = (8, 500)\n        figLayer = ScrollableLayer()\n        figLayer.add(fig)\n#\n        tileLayer = load('levelMap.xml')\n        solidTiles = tileLayer['solid']\n        nsoliTiles = tileLayer['not_solid']\n#\n        scrMang = ScrollingManager()\n        scrMang.add(nsoliTiles,z=-1)\n        scrMang.add(solidTiles,z=0)\n        scrMang.add(figLayer,z=1)\n#\n        gameSc = Scene(scrMang)\n        director.run(gameSc) Test your code. You should test your code often to make sure that the new features you implemented really work. The code in the example should now show some icy landscape behind the penguin. If the penguin looks like it is hovering far over the ice, you didn't do anything wrong, and it will be fixed in the next step. Add the controls. The player has many more ways to interact with the program in a 2D game than in a text-based game. A common one includes moving their figure when the correct key is pressed. Import everything from cocos.mapcolliders and from cocos.actions. Also import key from pyglet.window. \"Declare\" some global variables. Global variables are shared between functions. You can't really declare variables in Python, but you have to say that a global variable exists in the main code before using it. You can assign 0 as the value because a function will take care of assigning the correct value later. So add under the import expressions:\n\n# \"declaring\" global variables\nkeyboard = 0\nscrMang = 0\n\n\n\nAdjust your startGame function:\nSay that you use the global variables keyboard and scrMang. Do this by writing global keyboard, scrMang at the top of the function. Make the window listen to keyboard events. Tell the figure to act based on a PlatformerController. You'll implement that PlatformerController soon. Create a map collider to handle collisions between the solid tiles and the figure. def startGame():\n        global keyboard, scrMang\n        generateTilemap()\n#\n        fig = Sprite('pingu.png')\n        fig.position = (8, 250)\n        figLayer = ScrollableLayer()\n        figLayer.add(fig)\n#\n        tileLayer = load('levelMap.xml')\n        solidTiles = tileLayer['solid']\n        nsoliTiles = tileLayer['not_solid']\n#\n        keyboard = key.KeyStateHandler()\n        director.window.push_handlers(keyboard)\n#\n        fig.do(PlatformerController())\n        mapcollider = RectMapCollider(velocity_on_bump='slide')\n        fig.collision_handler = make_collision_handler(mapcollider, solidTiles)\n#\n        scrMang = ScrollingManager()\n        scrMang.add(nsoliTiles,z=-1)\n        scrMang.add(solidTiles,z=0)\n        scrMang.add(figLayer,z=1)\n#\n        gameSc = Scene(scrMang)\n        director.run(gameSc)\n\n\n\nCreate a platformer controller. This is what will move the figure according to your keypresses. Define the platformer controller as a subclass of Action. Define the move speed, the jump speed and the gravity. Define the start function. This function is called once, when the platformer controller is connected to the figure. It should set its speed to 0 both in x and in y direction. Define the step function. It will be repeated while the scene is running. Tell the step function to use the global variables keyboard and scrMang. Get and change the velocity. Save the x and the y velocity in separate variables. Set the x velocity to either 1 or -1 (depending on whether the left or right key was pressed) multiplied with the move speed. Add gravity to the y velocity. Multiply it with downtime so it works the same way on slower devices. If the space key is pressed and the figure is standing on the ground, jump by changing y velocity to jump speed. Calculate to where the figure should move. Then let the collision handler adjust that position if it is inside of a solid tile. Finally, move the figure to the new adjusted position. Set the focus of the scrolling manager on the figure. This causes the camera to move in a reasonable way when the figure moves. class PlatformerController(Action):\n        global keyboard, scrMang\n        on_ground = True\n        MOVE_SPEED = 300\n        JUMP_SPEED = 500\n        GRAVITY = -1200\n        def start(self):\n                self.target.velocity = (0, 0)\n        def step(self, dt):\n                global keyboard, scroller\n                if dt > 0.1: # don't do anything while downtime to big\n                        return\n                vx, vy = self.target.velocity\n                vx = (keyboard[key.RIGHT] - keyboard[key.LEFT]) * self.MOVE_SPEED\n                vy += self.GRAVITY * dt\n                if self.on_ground and keyboard[key.SPACE]:\n                        vy = self.JUMP_SPEED\n                dx = vx * dt\n                dy = vy * dt\n                last = self.target.get_rect()\n                new = last.copy()\n                new.x += dx\n                new.y += dy\n                self.target.velocity = self.target.collision_handler(last, new, vx, vy)\n                self.on_ground = (new.y == last.y)\n                self.target.position = new.center\n                scrMang.set_focus(*new.center) Test your code. If you followed the example, you should now be able to move the penguin with the arrow keys and jump by pressing the space bar. Also, the penguin should now fall down instead of hovering over the ground. Let the game end. Even the games that can go on endlessly have a possibility to end them by losing. And since the level you made in the example with a function has an end, it should also be possible to win by coming to that end: Else, the player would only jump around on the ice blocks there, which would get boring after some time. Inside the platformer controller, after the focus set, get the figure's x and y position. If the y position is less than 0, call the function finishGame() (you'll write it later) with \"Game Over\" as an argument. If the x position is bigger than the size of the screen multiplied with 3 (you had set that as level size before). posX, posY = self.target.position\nif posY < 0:\n        finishGame(\"Game Over\")\n        return\nif posX > 800*3: # level size\n        finishGame(\"Level Completed\")\n        return\n\n\n\nDefine a class finishMenu. It should be like the main menu class you defined before, but instead of having an empty string as title, it should use a variable text which the __init__ function takes as argument. The menu items should be labeled \"Try again\" and \"Quit\" now, but the functions they call stay the same. class FinishMenu(Menu):\n        def __init__(self, text):\n                super(FinishMenu, self).__init__(text)\n                self.menu_valign = CENTER\n                self.menu_halign = CENTER\n                menuItems = [(MenuItem(\"Try again\", startGame)), (MenuItem(\"Quit\", pyglet.app.exit))]\n                self.create_menu(menuItems)\n\n\n\nDefine the function finishGame(). It should take text as an argument. It should make a scene out of the main menu background, a FinishMenu with the text argument being passed on to this menu. Then it should run this scene. def finishGame(text):\n        menuSc = Scene(MainMenuBgr())\n        menuSc.add(FinishMenu(text))\n        director.run(menuSc) Add credits. That's usually necessary if you used media that you didn't make yourself to credit its author. Also, you'll probably want the players to know that you wrote the game. The credits should be included in the game so that anyone who installs your game can see them without having to look deep into the game files. Create a file CREDITS and enter all your credits there, like this:\n\nPenguin:\n Kelvin Shadewing, under CC0\n\nIce block:\n Micha\u0142 Banas\n digit1024 on opengameart.org\n under CC-BY-SA 3.0\n\n\n\nGo back to your Python code and import Label from cocos.text. Define a subclass Credits of Layer. In its __init__ function, read the CREDITS file and make a text label at the correct position out of every line in it. class Credits(Layer):\n        def __init__(self):\n                super(Credits, self).__init__()\n                credFile = open(\"CREDITS\",\"r\")\n                creds = credFile.read()\n                creds = creds.split(\"\\n\")\n                for i in range(0, len(creds)):\n                        credLabel = Label(creds[i], font_size=32, anchor_x=\"left\", anchor_y=\"top\")\n                        credLabel.position = 25,500-(i+1)*40\n                        self.add(credLabel)\n\n\n\nGo to your main menu class and add a menu item labelled \"Credits\" that calls the function showCredits when clicked. Define a subclass BackToMainMenuButton of Menu. Make this a menu with one item, labelled \"Back\", that calls the showMainMenu function. This \"menu\", which is more like a button, should be vertically aligned to the bottom and horizontally to the top. class BackToMainMenuButton(Menu):\n        def __init__(self):\n                super(BackToMainMenuButton, self).__init__(\"\")\n                self.menu_valign = BOTTOM\n                self.menu_halign = LEFT\n                menuItems = [(MenuItem(\"Back\", showMainMenu))]\n                self.create_menu(menuItems)\n\n\n\nDefine the function showCredits. It should make a scene out of a MainMenuBgr layer and a Credits layer and run that scene. def showCredits():\n        credSc = Scene(MainMenuBgr())\n        credSc.add(Credits())\n        credSc.add(BackToMainMenuButton())\n        director.run(credSc) Check your code. When you think you finished your code, you should look over all of it again. This can help you notice if something can be optimized, or whether there are some unnecessary lines you forgot to delete. If you followed the example, your entire code should now look as follows:\n\nfrom cocos.director import *\nfrom cocos.menu import *\nfrom cocos.scene import *\nfrom cocos.layer import *\nfrom cocos.sprite import *\nfrom cocos.tiles import *\nfrom cocos.mapcolliders import *\nfrom cocos.actions import *\nfrom cocos.text import Label\n\nimport pyglet.app\nfrom pyglet.window import key\nfrom math import ceil\nfrom random import randint\n\n# \"declaring\" global variables\nkeyboard = 0\nscrMang = 0\n\nclass MainMenuBgr(ColorLayer):\n        def __init__(self):\n                super(MainMenuBgr, self).__init__(0,200,255,255)\nclass MainMenu(Menu):\n        def __init__(self):\n                super(MainMenu, self).__init__(\"\")\n                self.menu_valign = CENTER\n                self.menu_halign = CENTER\n                menuItems = [(MenuItem(\"Start Game\", startGame)), (MenuItem(\"Credits\", showCredits)), (MenuItem(\"Quit\", pyglet.app.exit))]\n                self.create_menu(menuItems)\nclass Credits(Layer):\n        def __init__(self):\n                super(Credits, self).__init__()\n                credFile = open(\"CREDITS\",\"r\")\n                creds = credFile.read()\n                creds = creds.split(\"\\n\")\n                for i in range(0, len(creds)):\n                        credLabel = Label(creds[i], font_size=32, anchor_x=\"left\", anchor_y=\"top\")\n                        credLabel.position = 25,500-(i+1)*40\n                        self.add(credLabel)\nclass BackToMainMenuButton(Menu):\n        def __init__(self):\n                super(BackToMainMenuButton, self).__init__(\"\")\n                self.menu_valign = BOTTOM\n                self.menu_halign = LEFT\n                menuItems = [(MenuItem(\"Back\", showMainMenu))]\n                self.create_menu(menuItems)\nclass FinishMenu(Menu):\n        def __init__(self, text):\n                super(FinishMenu, self).__init__(text)\n                self.menu_valign = CENTER\n                self.menu_halign = CENTER\n                menuItems = [(MenuItem(\"Try again\", startGame)), (MenuItem(\"Quit\", pyglet.app.exit))]\n                self.create_menu(menuItems)\nclass PlatformerController(Action):\n        global keyboard, scrMang\n        on_ground = True\n        MOVE_SPEED = 300\n        JUMP_SPEED = 500\n        GRAVITY = -1200\n        def start(self):\n                self.target.velocity = (0, 0)\n        def step(self, dt):\n                global keyboard, scroller\n                if dt > 0.1: # don't do anything while downtime too big\n                        return\n                vx, vy = self.target.velocity\n                vx = (keyboard[key.RIGHT] - keyboard[key.LEFT]) * self.MOVE_SPEED\n                vy += self.GRAVITY * dt\n                if self.on_ground and keyboard[key.SPACE]:\n                        vy = self.JUMP_SPEED\n                dx = vx * dt\n                dy = vy * dt\n                last = self.target.get_rect()\n                new = last.copy()\n                new.x += dx\n                new.y += dy\n                self.target.velocity = self.target.collision_handler(last, new, vx, vy)\n                self.on_ground = (new.y == last.y)\n                self.target.position = new.center\n                scrMang.set_focus(*new.center)\n                posX, posY = self.target.position\n                if posY < 0:\n                        finishGame(\"Game Over\")\n                        return\n                if posX > 800*3: # level size\n                        finishGame(\"Level Completed\")\n                        return\n\ndef finishGame(text):\n        menuSc = Scene(MainMenuBgr())\n        menuSc.add(FinishMenu(text))\n        director.run(menuSc)\n\ndef showCredits():\n        credSc = Scene(MainMenuBgr())\n        credSc.add(Credits())\n        credSc.add(BackToMainMenuButton())\n        director.run(credSc)\n\ndef generateTilemap():\n        colAmount = ceil(800 / 16)*3 # (screen width / tile size) * 3\n        rowAmount = ceil(600 / 16) # screen height / tile size\n        tileFile = open(\"levelMap.xml\",\"w\")\n        tileFile.write('<resource>\\n<requires file=\"icyTiles.xml\" />\\n<rectmap id=\"solid\" origin=\"0,0,0\" tile_size=\"16x16\">\\n')\n        iceHeight = randint(1,10)\n        for i in range(0,colAmount):\n                tileFile.write('<column>')\n                makeHole = False\n                if randint(0,50) == 10 and i != 0: # don't allow holes at the spawnpoint\n                        makeHole = True\n                for j in range(0,rowAmount):\n                        if makeHole:\n                                tileFile.write('<cell />\\n')\n                        else:\n                                if j <= iceHeight:\n                                        tileFile.write('<cell tile=\"ice\" />\\n')\n                                else:\n                                        tileFile.write('<cell />\\n')\n                iceHeight = randint(iceHeight-5, iceHeight+5)\n                if iceHeight < 0: # limit tiles from going too low\n                        iceHeight = randint(1,5)\n                if iceHeight > rowAmount: # limit tiles from going too high\n                        iceHeight = randint(int(rowAmount/2)-5,int(rowAmount/2)+5)\n                tileFile.write('</column>\\n')\n        tileFile.write('</rectmap>\\n<rectmap id=\"not_solid\" origin = \"0,0,0\" tile_size=\"16x16\">\\n')\n        for i in range(0,colAmount):\n                tileFile.write('<column>')\n                for j in range(0,rowAmount):\n                        tileFile.write('<cell tile=\"sky\" />\\n')\n                tileFile.write('</column>\\n')\n        tileFile.write('</rectmap>\\n</resource>\\n')\n        tileFile.close()\n\ndef startGame():\n        global keyboard, scrMang\n        generateTilemap()\n#\n        fig = Sprite('pingu.png')\n        fig.position = (8, 250)\n        figLayer = ScrollableLayer()\n        figLayer.add(fig)\n#\n        tileLayer = load('levelMap.xml')\n        solidTiles = tileLayer['solid']\n        nsoliTiles = tileLayer['not_solid']\n#\n        keyboard = key.KeyStateHandler()\n        director.window.push_handlers(keyboard)\n#\n        fig.do(PlatformerController())\n        mapcollider = RectMapCollider(velocity_on_bump='slide')\n        fig.collision_handler = make_collision_handler(mapcollider, solidTiles)\n#\n        scrMang = ScrollingManager()\n        scrMang.add(nsoliTiles,z=-1)\n        scrMang.add(solidTiles,z=0)\n        scrMang.add(figLayer,z=1)\n#\n        gameSc = Scene(scrMang)\n        director.run(gameSc)\n\ndef showMainMenu():\n        menuSc = Scene(MainMenuBgr())\n        menuSc.add(MainMenu())\n        director.run(menuSc)\n\nwindow = director.init(caption=\"IcyPlat - a simple platformer\", resizable=True)\nshowMainMenu()\n\n\nThat are 168 lines totally, and 152 lines if you only count the code. This make seem like much, but for such a complex game, this actually is a small amount. Finished. Now test the game. When you program something, you have to check whether it works whenever you have implemented something new. Also, you might like to play the game you wrote for some time. Making a Game with 3D Graphics Choose your tools. 3D graphics are even more complicated than 2D graphics, and require their own libraries. Again, you might find an engine useful for things like collision detection in a game. For most games, you will need or edit 3D models. So you should have at least basic knowledge of a 3D editing program like Blender. This article will show how to make a Pong game in 3D with Panda3D. Install the tools. Panda3D can be installed with python3 -m pip install --extra-index-url https://archive.panda3d.org/ panda3d. Blender can either be installed from your system's package manager or from its website. Make a new directory. You should keep all files for your game in this folder. This will let you keep your computer tidy and see quickly what files you have for the program. Create an empty window. Import a library that's necessary to create the window: from direct.showbase.ShowBase import ShowBase. Also, import everything from the panda3d.core library (with from panda3d.core import *). Define a subclass MyApp of ShowBase. In its initialization function, write loadPrcFileData('', 'window-title 3D Pong')\n This is the function that changes window properties, in this case the window caption to \"3D Pong\". After that, initialize the parent class ShowBase. Create an object app of the class MyApp. Run it to show the window. from direct.showbase.ShowBase import ShowBase\nfrom panda3d.core import *\n\nclass MyApp(ShowBase):\n        def __init__(self):\n                loadPrcFileData('', 'window-title 3D Pong')\n                ShowBase.__init__(self)\n\napp = MyApp()\napp.run() Create a 3D model. You need to create the things you want to show in a 3D game in a 3D editing program first, for example in Blender. You should start with one 3D model, add it, and only then proceed to the other ones. This way, you'll avoid having to repeat a lot of work if you do something wrong at first. Make sure that your 3D models aren't unnecessarily complex, since that can slow down the game. Open Blender. Delete the default cube and add an \"Ico Sphere\" instead. It doesn't appear to be really spherical in Blender itself, but looks close enough to a sphere in the actual game. You could have used the UV sphere, but it is way more complex and so takes more time to render. Warning: Make sure that every object is centered on the point (0, 0, 0) in Blender, and has its origin on the centre of its mass (use Object \u2192 Transform \u2192 Origin to Center of Mass). Otherwise, there will be problems with collision detection later. Export to a format your 3D library can use. Like for 2D images, there are different formats for 3D models. You should use one that your 3D library can understand and show. Refer to its documentation if you're not sure which formats it supports. For the example, you need to export the ball model to the Panda3D format. First, save your model as a normal .blend file. This will let you make changes if you need the ball to look differently. Use some reasonable filename you can remember, like ball.blend. Enable export to the DirectX format in Blender. For this, either go to File \u2192 User Preferences... or press Ctrl+Alt+U. In the window that opens, select the category Import-Export. Find DirectX X Format and tick the checkbox to the right of it. Click on Save User Settings and close the window. Export the model to DirectX X format by going to File \u2192 Export \u2192 DirectX (.x), specifying a file name (again, choose something like ball.x and clicking on Export DirectX. Convert DirectX .x to Panda3D .egg. Panda3D already provides a tool to do this. It's called x2egg and the syntax is the following: x2egg input.x output.egg. So to convert your file, type: x2egg ball.x ball.egg. Load the model into your program. This is what actually will allow you to see it in the program and do something with it. Set the background colour to black. This will let you better see the models you load. This is done like setting the caption, but with another option: loadPrcFileData('', 'background-color 0 0 0 0')\n Make sure to do this before initializing the window. Go to the end of the __init__ function. Load the model with self.ball = loader.loadModel(\"ball.egg\")\n Note that the model file has to be in the same directory as the program file. Loading the model won't let it appear yet, but it's still necessary. Also, the self. in front of the variable name, which makes it an attribute of the class MyApp, will be useful later, so do this in front of every object you want to change later. Render the loaded model. This is done with ball.reparentTo(self.render). Set the correct position for the ball. It should be at 0, 0, 0 at the beginning. The first coordinate is left/right, the second is forward/backward, the third is down/up. The command for this is self.ball.setPos(0, 0, 0). If you don't see anything yet, this is normal. Try moving the mouse up while holding its right button pressed. Then you should see it. This is because the camera is also at 0, 0, 0 \u2014 inside the ball \u2014 so you don't see it. The right mouse button moves the camera forward and backward. Set the camera position. The camera should be at a position where everything can be seen well. Since this is not necessarily the case by default, and because defaults can vary from platform to platform in the same software, you should set the camera position explicitly. First, you need to disable the mouse controls, else Panda3D refuses to set the camera to another position in the program. Then, you can actually set the camera position. Your code should now look as follows:\n\nfrom direct.showbase.ShowBase import ShowBase\nfrom panda3d.core import *\n\nclass MyApp(ShowBase):\n        def __init__(self):\n#               Initialize the window\n                loadPrcFileData('', 'window-title 3D Pong')\n                loadPrcFileData('', 'background-color 0 0 0 0')\n                ShowBase.__init__(self)\n#               Load ball model\n                self.ball = loader.loadModel(\"ball.egg\")\n                self.ball.reparentTo(self.render)\n                self.ball.setPos(0, 0, 0)\n#               Set correct camera position\n                self.disableMouse()\n                camera.setPos(0,-30,0)\n\napp = MyApp()\napp.run() Set up the rest of the scene. When making and loading one model works, you can proceed to make and add the others you need for your scene. Add the walls and bats. Follow the steps described for the ball, except that you don't have to enable the DirectX exporter again. Although there are four walls and two bats, you only need one model of both. Make the wall a thin rectangle that covers the entire Blender \"floor\" and the bat a thin square that's around 2 Blender units high. You'll have to set the positions, rotations and scales manually in the code, so that the ends of the walls touch each other to form a closed shape. You can try to find the correct numbers yourself, or look in the code below, which belongs into the __init__ function under where the ball model is loaded. Also, you have to set the camera closer to the user, to -60 instead of -30. #               Load walls models\n                wallLeft = loader.loadModel(\"wall.egg\"); wallLeft.reparentTo(self.render)\n                wallLeft.setPosHprScale(-15,0,0, 0,0,90, 2,2,1)\n                wallRight = loader.loadModel(\"wall.egg\"); wallRight.reparentTo(self.render)\n                wallRight.setPosHprScale(15,0,0, 0,0,90, 2,2,1)\n                wallBottom = loader.loadModel(\"wall.egg\"); wallBottom.reparentTo(self.render)\n                wallBottom.setPosHprScale(0,0,15, 0,0,0, 2,2,1)\n                wallTop = loader.loadModel(\"wall.egg\"); wallTop.reparentTo(self.render)\n                wallTop.setPosHprScale(0,0,-15, 0,0,0, 2,2,1)\n#               Load bat models\n                self.batPlay = loader.loadModel(\"bat.egg\"); batPlay.reparentTo(self.render)\n                self.batPlay.setPos(-5,-15,-5)\n                self.batPlay.setScale(3,1,3)\n                self.batOpp = loader.loadModel(\"bat.egg\"); batOpp.reparentTo(self.render)\n                self.batOpp.setPos(5,15,-5)\n                self.batOpp.setScale(3,1,3) Add lighting. Now, all objects are present, but it doesn't quite look natural and it's hard to see depth. This can be fixed with lighting. Note that the lights themselves will not be visible and that there are different types of lights. The ones you need for the example game are:\nPoint lights. They emit lights in all directions, like an infinitely small lightbulb. Since they light different objects different because of direction and distance, they will create shadows which will make the scene look more natural. Ambient lights. They don't really have a direction or position, they just light the entire scene the same way. This can't help depth perception, but it makes sure that everything can be seen well. Add the lights with the following code:\n\n#               Lighting\n                alight = AmbientLight('alight')\n                alight.setColor(VBase4(0.1, 0.1, 0.1, 1))\n                alnp = render.attachNewNode(alight)\n                render.setLight(alnp)\n                plight = PointLight('plight')\n                plight.setColor(VBase4(0.9, 0.9, 0.9, 1))\n                plnp = render.attachNewNode(plight)\n                plnp.setPos(0,-16,0)\n                render.setLight(plnp) Add controls. As in other types of games, the player should be able to interact with the game world in some way. Like in 2D games, a common way to do this in 3D games is by making a figure do something when the correct keys are pressed. For this program, you should move the bat when a key is pressed. When a key is pressed, the event is called the same as the key. When a key is held down, this results in a series of events called like the key with -repeat at the end. Make the program call a function when a key is pressed. This is done with the self.accept function. So, for example, calling a function moveLeft when the key a is pressed would be done with self.accept(\"a\", moveLeft). Write the following code into your __init__ function: \n\n#               Move when key pressed\n                self.accept(\"a\", self.moveLeft)\n                self.accept(\"a-repeat\", self.moveLeft)\n                self.accept(\"d\", self.moveRight)\n                self.accept(\"d-repeat\", self.moveRight)\n                self.accept(\"w\", self.moveUp)\n                self.accept(\"w-repeat\", self.moveUp)\n                self.accept(\"s\", self.moveDown)\n                self.accept(\"s-repeat\", self.moveDown)\n\n\n\nDefine the functions that are called by the events. They will move the player's bat appropriately. Make sure that the functions are still in the class MyApp. def moveLeft(self):\n                self.batPlay.setX(self.batPlay.getX()-1)\n        def moveRight(self):\n                self.batPlay.setX(self.batPlay.getX()+1)\n        def moveUp(self):\n                self.batPlay.setZ(self.batPlay.getZ()+1)\n        def moveDown(self):\n                self.batPlay.setZ(self.batPlay.getZ()-1) Add collision detection. Collision detection allows you to notice if two objects are inside of each other, and take the correct measures. You can use it, for example, to prevent the player from going through a wall or to make something that is thrown bounce off when it hits the floor. First, you should do the collision detection for the bats, because you can test it now. You will add the collision detection for the ball later, since it requires different actions. Add a collision traverser. This is the prerequisite for any collision detection in Panda3D and is done withbase.cTrav = CollisionTraverser()\nWhile implementing the collision detection, it is useful to see whether a collision was noticed. Make the collisions visible with base.cTrav.showCollisions(render)\n\n\nCreate a notifier. As its name says, this object will notify the program that some objects collided or are still colliding. You could also make it notify that some objects are no longer colliding, but you don't need it for this game. self.notifier = CollisionHandlerEvent()\n                self.notifier.addInPattern(\"%fn-in-%in\")\n                self.notifier.addAgainPattern(\"%fn-again-%in\")\n\n\n\nMake the program call a function when two objects collide. This is done the same way as with the key presses. For example, if the player's bat collides with the left wall, the event is called \"batPlay-in-wallLeft\". So calling a function blockCollision would be done with self.accept(\"batPlay-in-wallLeft\", self.blockCollision). Set up collision boxes for all the objects you want to detect collisions of. For now, this means all the walls and the two bats. Note that you have to add the line base.cTrav.addCollider(batPlayColl, self.notifier) to every object that can collide with something (the bats in this case), while every object with a collision shape can automatically be collided into. The collision box takes four arguments to be created: the position relative to the centre of the object it applies to, and the scale in x, y and z direction relative to that object. For example:\n\n                batPlayColl = self.batPlay.attachNewNode(CollisionNode(\"batPlay\"))\n                batPlayColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                batPlayColl.show()\n\n\n\nDefine the function for the collision events. Since the behaviour is basically the same in all the cases, you should only define one function that handles all these collisions between a bat and a wall. It should move the bat back to a position where it doesn't collide with the wall. Ideally, that would be handled by setting the position of entry.getFromNodePath(), but that doesn't work, so you have to treat the operations of both bats as separate cases. {{greenbox: Tip: The collision boxes make the game look a bit strange. But while not all collisions are implemented and work flawlessly, it's best to leave them there. After that, you can make them invisible by removing the line base.cTrav.showCollisions(render) and all the lines are the name of a collision shape with .show() at the end. Your entire code should now look like this:\n\nfrom direct.showbase.ShowBase import ShowBase\nfrom panda3d.core import *\n\n\nclass MyApp(ShowBase):\n        def __init__(self):\n#               Initialize the window\n                loadPrcFileData('', 'window-title 3D Pong')\n                loadPrcFileData('', 'background-color 0 0 0 0')\n                ShowBase.__init__(self)\n#               Initialize collision detection\n                base.cTrav = CollisionTraverser()\n                base.cTrav.showCollisions(render)\n                self.notifier = CollisionHandlerEvent()\n                self.notifier.addInPattern(\"%fn-in-%in\")\n                self.notifier.addAgainPattern(\"%fn-again-%in\")\n                self.accept(\"batPlay-in-wallLeft\", self.blockCollision)\n                self.accept(\"batPlay-again-wallLeft\", self.blockCollision)\n                self.accept(\"batPlay-in-wallRight\", self.blockCollision)\n                self.accept(\"batPlay-again-wallRight\", self.blockCollision)\n                self.accept(\"batPlay-in-wallBottom\", self.blockCollision)\n                self.accept(\"batPlay-again-wallBottom\", self.blockCollision)\n                self.accept(\"batPlay-in-wallTop\", self.blockCollision)\n                self.accept(\"batPlay-again-wallTop\", self.blockCollision)\n                self.accept(\"batOpp-in-wallLeft\", self.blockCollision)\n                self.accept(\"batOpp-again-wallLeft\", self.blockCollision)\n                self.accept(\"batOpp-in-wallRight\", self.blockCollision)\n                self.accept(\"batOpp-again-wallRight\", self.blockCollision)\n                self.accept(\"batOpp-in-wallBottom\", self.blockCollision)\n                self.accept(\"batOpp-again-wallBottom\", self.blockCollision)\n                self.accept(\"batOpp-in-wallTop\", self.blockCollision)\n                self.accept(\"batOpp-again-wallTop\", self.blockCollision)\n#               Load ball model\n                self.ball = loader.loadModel(\"ball.egg\")\n                self.ball.reparentTo(self.render)\n                self.ball.setPos(0, 0, 0)\n#               Load walls models and define their collision boxes\n                wallLeft = loader.loadModel(\"wall.egg\"); wallLeft.reparentTo(self.render)\n                wallLeft.setPosHprScale(-15,0,0, 0,0,90, 2,2,1)\n                wallLeftColl = wallLeft.attachNewNode(CollisionNode(\"wallLeft\"))\n                wallLeftColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallLeftColl.show()\n                wallRight = loader.loadModel(\"wall.egg\"); wallRight.reparentTo(self.render)\n                wallRight.setPosHprScale(15,0,0, 0,0,90, 2,2,1)\n                wallRightColl = wallRight.attachNewNode(CollisionNode(\"wallRight\"))\n                wallRightColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallRightColl.show()\n                wallBottom = loader.loadModel(\"wall.egg\"); wallBottom.reparentTo(self.render)\n                wallBottom.setPosHprScale(0,0,15, 0,0,0, 2,2,1)\n                wallBottomColl = wallBottom.attachNewNode(CollisionNode(\"wallBottom\"))\n                wallBottomColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallBottomColl.show()\n                wallTop = loader.loadModel(\"wall.egg\"); wallTop.reparentTo(self.render)\n                wallTop.setPosHprScale(0,0,-15, 0,0,0, 2,2,1)\n                wallTopColl = wallTop.attachNewNode(CollisionNode(\"wallTop\"))\n                wallTopColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallTopColl.show()\n#               Load bat models\n                self.batPlay = loader.loadModel(\"bat.egg\"); self.batPlay.reparentTo(self.render)\n                self.batPlay.setScale(3,1,3)\n                self.batPlay.setPos(-5,-15,-5)\n                batPlayColl = self.batPlay.attachNewNode(CollisionNode(\"batPlay\"))\n                batPlayColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                batPlayColl.show()\n                base.cTrav.addCollider(batPlayColl, self.notifier)\n                self.batOpp = loader.loadModel(\"bat.egg\"); self.batOpp.reparentTo(self.render)\n                self.batOpp.setPos(5,15,-5)\n                self.batOpp.setScale(3,1,3)\n                batOppColl = self.batOpp.attachNewNode(CollisionNode(\"batOpp\"))\n                batOppColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                batOppColl.show()\n                base.cTrav.addCollider(batOppColl, self.notifier)\n#               Set correct camera position\n#               self.disableMouse()\n                camera.setPos(0,-60,0)\n#               Lighting\n                alight = AmbientLight('alight')\n                alight.setColor(VBase4(0.1, 0.1, 0.1, 1))\n                alnp = render.attachNewNode(alight)\n                render.setLight(alnp)\n                plight = PointLight('plight')\n                plight.setColor(VBase4(0.9, 0.9, 0.9, 1))\n                plnp = render.attachNewNode(plight)\n                plnp.setPos(0,-16,0)\n                render.setLight(plnp)\n#               Move when key pressed\n                self.accept(\"a\", self.moveLeft)\n                self.accept(\"a-repeat\", self.moveLeft)\n                self.accept(\"d\", self.moveRight)\n                self.accept(\"d-repeat\", self.moveRight)\n                self.accept(\"w\", self.moveUp)\n                self.accept(\"w-repeat\", self.moveUp)\n                self.accept(\"s\", self.moveDown)\n                self.accept(\"s-repeat\", self.moveDown)\n        def moveLeft(self):\n                self.batPlay.setX(self.batPlay.getX()-1)\n        def moveRight(self):\n                self.batPlay.setX(self.batPlay.getX()+1)\n        def moveUp(self):\n                self.batPlay.setZ(self.batPlay.getZ()+1)\n        def moveDown(self):\n                self.batPlay.setZ(self.batPlay.getZ()-1)\n        def blockCollision(self, entry):\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batPlay\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batPlay.setX(-15+entry.getIntoNodePath().getSx()+self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batPlay.setX(15-entry.getIntoNodePath().getSx()-self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\n                                self.batPlay.setZ(15-entry.getIntoNodePath().getSz()-self.batPlay.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batPlay.setZ(-15+entry.getIntoNodePath().getSz()+self.batPlay.getSz())\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batOpp\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batOpp.setX(-15+entry.getIntoNodePath().getSx()+self.batOpp.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batOpp.setX(15-entry.getIntoNodePath().getSx()-self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\nself.batPlay.setZ(15-entry.getIntoNodePath().getSz()-self.batPlay.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batPlay.setZ(-15+entry.getIntoNodePath().getSz()+self.batPlay.getSz())\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batOpp\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batOpp.setX(-15+entry.getIntoNodePath().getSx()+self.batOpp.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batOpp.setX(15-entry.getIntoNodePath().getSx()-self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\n                                self.batPlay.setZ(10-entry.getIntoNodePath().getSz()-self.batPlay.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batPlay.setZ(-20+entry.getIntoNodePath().getSz()+self.batPlay.getSz())\n\napp = MyApp()\napp.run() Add movement. Not only should the player see some response when they press a key, some objects should also move on their own: this can be used to demand a reaction from the player, or just as nice background detail. Make the ball move. It will fly through the walls for now, but you'll fix that in the next step. Import the functions randint and randrange from the random library. Also, import Task from direct.task. Calculate the speed the ball should have at the beginning. Go to the end of the __init__ function for this. Create a vector of 3 random integers. Note that the y speed is always the same, just either negative or positive. Normalize that vector, i. e. change its components so that their relation is kept, but the vector's total length is 1. Divide that normalized vector by 5 so that the ball doesn't fly too fast. #               Make the ball move\n                self.ballSpeed = VBase3(randint(-10,10),randrange(-1,1,2),randint(-10,10))\n                self.ballSpeed.normalize()\n                self.ballSpeed /= 5\n\n\n\nCreate a task. In Panda3D, a task means calling a function every frame. Write following code under the speed calculations:self.taskMgr.add(self.updateBallPos, \"UpdateBallPos\")\n\n\nDefine the task function. The function should simply add the speed to the ball position. Then, it should return Task.cont, which makes the function being called again next frame. def updateBallPos(self, task):\n                self.ball.setPos(self.ball.getPos()+self.ballSpeed)\n                return Task.cont Add collision detection for the moving objects as well. Pay attention to fast-moving objects: they might require a special kind of collision detection that also looks at the previous frames to determine whether the objects collided at any time, even if it was too fast to happen in any frame. You should make the ball bounce off whenever it collides with something. This will prevent it from flying through the walls or bats. Enable fluid collision detection. For fast-moving objects like the ball in this game, there is a problem with normal collision detection: If the object is in front of what it will collide into in one frame, and already behind it in the next frame, the collision isn't detected. But it's detect such collisions with some adjustments: go to where you initialized the collision traverser and add the line base.cTrav.setRespectPrevTransform(True)\nThen, go to updateBallPos and replace setPos with setFluidPos. Accept ball collision events. Your program should notice collisions between the ball and the walls or the bat. Don't add the again events this time, since you should make sure that the ball only changes direction once \u2014 if it changes direction two times, it just continues flying through the wall or bat. Define the bounceOff function that is called every time the ball collides. To reverse direction, set it to its negative. Use whatever direction the ball was going to escape in: for example, if it collides with the left or right wall, reverse the x-direction. def bounceOff(self, entry):\n                if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\" or str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                        self.ballSpeed[0] = -self.ballSpeed[0]\n                if str(entry.getIntoNodePath()) == \"render/bat.egg/batPlay\" or str(entry.getIntoNodePath()) == \"render/bat.egg/batOpp\":\n                        self.ballSpeed[1] = -self.ballSpeed[1]\n                if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\" or str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                        self.ballSpeed[2] = -self.ballSpeed[2]\n\n\n\nAdjust inappropriate values. Now you can test what it's like to play the game, although the opponent will miss the ball with very high probability. But you can test whether you can see the ball well and hit it yourself. You could move the camera back to -75 and the bats to \u00b125 for an easier gameplay. You could also make the ball bigger so that it's easier to see in which direction it is moving and how close it is. You can make the walls a bit longer (scale 3 instead of 2 in Y-direction) so that the ball can't fly outside the field of view before getting behind the bat. Define the opponent's behaviour. If your game has any sort of opponent, you will have to program their behaviour because the player is very unlikely to have a real opponent. Surely, there are network multiplayer games where the player has to play against another player on another computer, but they're very hard to program and many of them also have a singleplayer option. Add another task. Make this one call a function named directOpponent. Define the function directOpponent. Just directing the bat to follow the ball in X/Z direction is easy. The problem is that the opponent also has to make mistakes, so that the player has a chance to win. This can be done with the correct amount of randomness. In the function below, the opponent's bat either moves in the correct direction or in the opposite direction. This makes it possible to miss the ball sometimes. Make the positive number higher if you want the opponent to hit the ball more often, and the negative number lower if you want it to miss the ball more often. If you do both, the effects will cancel each other out. def directOpponent(self, task):\n                dirX = randint(-2,4)*(self.ball.getX() - self.batOpp.getX())\n                dirZ = randint(-2,4)*(self.ball.getZ() - self.batOpp.getZ())\n                self.batOpp.setX(self.batOpp.getX() + copysign(1/7, dirX))\n                self.batOpp.setZ(self.batOpp.getZ() + copysign(1/7, dirZ))\n                return Task.cont\n\n\n\nPlay the game. While the ball still is gone forever when either the player or the opponent miss, it's already possible to test the gameplay and adjust something if necessary. Make the collision boxes invisible now. There are many collisions in this game, and the constant flashing of the boxes can distract and annoy. So remove the line base.cTrav.showCollisions(render) and all the lines are the name of a collision shape with .show() at the end, like for example wallLeftColl.show(). Establish limits. If, except of other objects to collide with, the objects have no limits of where they can move, this can cause problems. If, for example, the player throws a ball and it never comes back, they will be quite annoyed about it. In the example, the program should detect when the ball is out of the field. If this happens, the program should put it back to (0,0,0) and give a point to the player that didn't miss. Import OnscreenText from direct.gui.OnscreenText. Define the score as a list. It should have two items that are both set to 0 at the beginning. Display the text as OnscreenText. Positioning is different here: the first number is left/right, and the second is down/up. Both have half the screen as 1 unit. fg sets the colour of the text. #               Count the scores\n                self.scores = [0,0]\n                self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n\n\n\nAdd two if-statements to the updateBallPos function. They should check whether the ball is beyond 26 or -26, and if that's the case, put the ball back to (0,0,0) and increment the appropriate score (either the player's or the opponent's). def updateBallPos(self, task):\n                self.ball.setFluidPos(self.ball.getPos()+self.ballSpeed)\n                if self.ball.getY() > 26:\n                        self.scores[0] += 1\n                        self.ball.setPos(0,0,0)\n                        self.scoreCount.destroy() # destroy last text before adding new\n                        self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n                if self.ball.getY() < -26:\n                        self.scores[1] += 1\n                        self.ball.setPos(0,0,0)\n                        self.scoreCount.destroy()\n                        self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n                return Task.cont Check your code. If you wrote the game in the example, your entire code should now look like this:\n\nfrom direct.showbase.ShowBase import ShowBase\nfrom direct.task import Task\nfrom panda3d.core import *\nfrom direct.gui.OnscreenText import OnscreenText\nfrom random import randint, randrange\nfrom math import copysign\n\nclass MyApp(ShowBase):\n        def __init__(self):\n#               Initialize the window\n                loadPrcFileData('', 'window-title 3D Pong')\n                loadPrcFileData('', 'background-color 0 0 0 0')\n                ShowBase.__init__(self)\n#               Initialize collision detection\n                base.cTrav = CollisionTraverser()\n                base.cTrav.setRespectPrevTransform(True)\n                self.notifier = CollisionHandlerEvent()\n                self.notifier.addInPattern(\"%fn-in-%in\")\n                self.notifier.addAgainPattern(\"%fn-again-%in\")\n                self.accept(\"batPlay-in-wallLeft\", self.blockCollision)\n                self.accept(\"batPlay-again-wallLeft\", self.blockCollision)\n                self.accept(\"batPlay-in-wallRight\", self.blockCollision)\n                self.accept(\"batPlay-again-wallRight\", self.blockCollision)\n                self.accept(\"batPlay-in-wallBottom\", self.blockCollision)\n                self.accept(\"batPlay-again-wallBottom\", self.blockCollision)\n                self.accept(\"batPlay-in-wallTop\", self.blockCollision)\n                self.accept(\"batPlay-again-wallTop\", self.blockCollision)\n                self.accept(\"batOpp-in-wallLeft\", self.blockCollision)\n                self.accept(\"batOpp-again-wallLeft\", self.blockCollision)\n                self.accept(\"batOpp-in-wallRight\", self.blockCollision)\n                self.accept(\"batOpp-again-wallRight\", self.blockCollision)\n                self.accept(\"batOpp-in-wallBottom\", self.blockCollision)\n                self.accept(\"batOpp-again-wallBottom\", self.blockCollision)\n                self.accept(\"batOpp-in-wallTop\", self.blockCollision)\n                self.accept(\"batOpp-again-wallTop\", self.blockCollision)\n                self.accept(\"ball-in-wallLeft\", self.bounceOff)\n                self.accept(\"ball-in-wallRight\", self.bounceOff)\n                self.accept(\"ball-in-wallBottom\", self.bounceOff)\n                self.accept(\"ball-in-wallTop\", self.bounceOff)\n                self.accept(\"ball-in-batPlay\", self.bounceOff)\n                self.accept(\"ball-in-batOpp\", self.bounceOff)\n#               Load ball model\n                self.ball = loader.loadModel(\"ball.egg\")\n                self.ball.reparentTo(self.render)\n                self.ball.setPos(0, 0, 0)\n                ballColl = self.ball.attachNewNode(CollisionNode(\"ball\"))\n                ballColl.node().addSolid(CollisionSphere(0, 0, 0, 0.25))\n                ballColl.show()\n                base.cTrav.addCollider(ballColl, self.notifier)\n#               Load walls models and define their collision boxes\n                wallLeft = loader.loadModel(\"wall.egg\"); wallLeft.reparentTo(self.render)\n                wallLeft.setPosHprScale(-15,0,0, 0,0,90, 2,3,1)\n                wallLeftColl = wallLeft.attachNewNode(CollisionNode(\"wallLeft\"))\n                wallLeftColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallRight = loader.loadModel(\"wall.egg\"); wallRight.reparentTo(self.render)\n                wallRight.setPosHprScale(15,0,0, 0,0,90, 2,3,1)\n                wallRightColl = wallRight.attachNewNode(CollisionNode(\"wallRight\"))\n                wallRightColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallBottom = loader.loadModel(\"wall.egg\"); wallBottom.reparentTo(self.render)\n                wallBottom.setPosHprScale(0,0,15, 0,0,0, 2,3,1)\n                wallBottomColl = wallBottom.attachNewNode(CollisionNode(\"wallBottom\"))\n                wallBottomColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n                wallTop = loader.loadModel(\"wall.egg\"); wallTop.reparentTo(self.render)\n                wallTop.setPosHprScale(0,0,-15, 0,0,0, 2,3,1)\n                wallTopColl = wallTop.attachNewNode(CollisionNode(\"wallTop\"))\n                wallTopColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 10, 10, 0.25))\n#               Load bat models\n                self.batPlay = loader.loadModel(\"bat.egg\"); self.batPlay.reparentTo(self.render)\n                self.batPlay.setScale(3,1,3)\n                self.batPlay.setPos(-5,-25,-5)\n                batPlayColl = self.batPlay.attachNewNode(CollisionNode(\"batPlay\"))\n                batPlayColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                base.cTrav.addCollider(batPlayColl, self.notifier)\n                self.batOpp = loader.loadModel(\"bat.egg\"); self.batOpp.reparentTo(self.render)\n                self.batOpp.setPos(5,25,-5)\n                self.batOpp.setScale(3,1,3)\n                batOppColl = self.batOpp.attachNewNode(CollisionNode(\"batOpp\"))\n                batOppColl.node().addSolid(CollisionBox(LPoint3(0,0,0), 1, 1, 1))\n                base.cTrav.addCollider(batOppColl, self.notifier)\n#               Set correct camera position\n                self.disableMouse()\n                camera.setPos(0,-75,0)\n#               Lighting\n                alight = AmbientLight('alight')\n                alight.setColor(VBase4(0.1, 0.1, 0.1, 1))\n                alnp = render.attachNewNode(alight)\n                render.setLight(alnp)\n                plight = PointLight('plight')\n                plight.setColor(VBase4(0.9, 0.9, 0.9, 1))\n                plnp = render.attachNewNode(plight)\n                plnp.setPos(0,-16,0)\n                render.setLight(plnp)\n#               Move when key pressed\n                self.accept(\"a\", self.moveLeft)\n                self.accept(\"a-repeat\", self.moveLeft)\n                self.accept(\"d\", self.moveRight)\n                self.accept(\"d-repeat\", self.moveRight)\n                self.accept(\"w\", self.moveUp)\n                self.accept(\"w-repeat\", self.moveUp)\n                self.accept(\"s\", self.moveDown)\n                self.accept(\"s-repeat\", self.moveDown)\n#               Make the ball move\n                self.ballSpeed = VBase3(randint(-10,10),randrange(-1,2,2)*8,randint(-10,10))\n                self.ballSpeed.normalize()\n                self.ballSpeed /= 7\n                self.taskMgr.add(self.updateBallPos, \"UpdateBallPos\")\n                self.taskMgr.add(self.directOpponent, \"DirectOpponent\")\n#               Count the scores\n                self.scores = [0,0]\n                self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n        def moveLeft(self):\n                self.batPlay.setX(self.batPlay.getX()-1)\n        def moveRight(self):\n                self.batPlay.setX(self.batPlay.getX()+1)\n        def moveUp(self):\n                self.batPlay.setZ(self.batPlay.getZ()+1)\n        def moveDown(self):\n                self.batPlay.setZ(self.batPlay.getZ()-1)\n        def blockCollision(self, entry):\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batPlay\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batPlay.setX(-15+entry.getIntoNodePath().getSx()+self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batPlay.setX(15-entry.getIntoNodePath().getSx()-self.batPlay.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\n                                self.batPlay.setZ(15-entry.getIntoNodePath().getSz()-self.batPlay.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batPlay.setZ(-15+entry.getIntoNodePath().getSz()+self.batPlay.getSz())\n                if str(entry.getFromNodePath()) == \"render/bat.egg/batOpp\":\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\":\n                                self.batOpp.setX(-15+entry.getIntoNodePath().getSx()+self.batOpp.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                                self.batOpp.setX(15-entry.getIntoNodePath().getSx()-self.batOpp.getSx())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\":\n                                self.batOpp.setZ(15-entry.getIntoNodePath().getSz()-self.batOpp.getSz())\n                        if str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                                self.batOpp.setZ(-15+entry.getIntoNodePath().getSz()+self.batOpp.getSz())\n        def bounceOff(self, entry):\n                if str(entry.getIntoNodePath()) == \"render/wall.egg/wallLeft\" or str(entry.getIntoNodePath()) == \"render/wall.egg/wallRight\":\n                        self.ballSpeed[0] = -self.ballSpeed[0]\n                if str(entry.getIntoNodePath()) == \"render/bat.egg/batPlay\" or str(entry.getIntoNodePath()) == \"render/bat.egg/batOpp\":\n                        self.ballSpeed[1] = -self.ballSpeed[1]\n                if str(entry.getIntoNodePath()) == \"render/wall.egg/wallBottom\" or str(entry.getIntoNodePath()) == \"render/wall.egg/wallTop\":\n                        self.ballSpeed[2] = -self.ballSpeed[2]\n        def updateBallPos(self, task):\n                self.ball.setFluidPos(self.ball.getPos()+self.ballSpeed)\n                if self.ball.getY() > 26:\n                        self.scores[0] += 1\n                        self.ball.setPos(0,0,0)\n                        self.scoreCount.destroy() # destroy last text before adding new\n                        self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n                if self.ball.getY() < -26:\n                        self.scores[1] += 1\n                        self.ball.setPos(0,0,0)\n                        self.scoreCount.destroy()\n                        self.scoreCount = OnscreenText(text = (str(self.scores[0]) + \" \" + str(self.scores[1])), pos = (0, 0.75), scale = 0.1, fg = (0, 255, 0, 0.5))\n                return Task.cont\n        def directOpponent(self, task):\n                dirX = randint(-2,4)*(self.ball.getX() - self.batOpp.getX())\n                dirZ = randint(-2,4)*(self.ball.getZ() - self.batOpp.getZ())\n                self.batOpp.setX(self.batOpp.getX() + copysign(1/7, dirX))\n                self.batOpp.setZ(self.batOpp.getZ() + copysign(1/7, dirZ))\n                return Task.cont\n\napp = MyApp()\napp.run()\n\n\nThat are 166 lines totally, and 152 lines of pure code. 3D games are very complex, so this is a normal amount of lines for such a game. Finished. This game has no possibility to win or lose at some point yet, and there is no possibility to restart it without restarting the program. Such features would make your program even more complex, so if you want more practice, try to implement them. Anyway, you should play the game for some time to check whether everything works as it should, and maybe to actually have fun with the game you wrote. Publishing the Game Write down the dependencies. Anyone who uses another computer will not have the same software and libraries installed as you. So you have to make sure that every user that installs your program also installs everything the program needs to work. You don't have to write down all dependencies of all dependencies of all dependencies and so on, because the list could become very long this way, but you should at least write the dependencies of your package and their dependencies. Check the licenses. This applies media, like images, 3D models or music, libraries and frameworks you used for your program, and anything used in your program that you didn't write yourself. Often there are some conditions, like having to credit the author or share modifications of the media under the same license. Sometimes it's also forbidden to use it for commercial purposes, like a game which you'll sell for money. If you have to credit the author, make sure to do it in a well-visible place, like a \"Credits\" tab in your game. There is also media with copyright claimed and no license specified, sometimes with some text like \"All rights reserved\". If that's the case, you must get explicit permission from the author before including it in your game. Libraries usually are released under some license that allows using them as libraries. A notable exception is the GPL without linking exception: such a license only allows to use it in a program with certain licenses. And you should always read at least the basic points of the license to make sure whatever you're doing with the media or library is allowed. Warning: Using media or libraries in a way that the license doesn't permit in a game that you publish can get you into serious legal trouble. So either ask the author or avoid the piece of media altogether if you are unsure about whether your usage is allowed. Decide on the conditions you want to publish your game on. While you have to be careful about the restrictions that your external media sets, you usually can decide on the license of your code yourself. You can use some very permissive license, like the CC0. You can use a license that allows distribution and modification under some conditions, like the BSD license or the GPL. Or you could make your software proprietary, meaning that nobody is allowed to distribute or modify it without your permission. Decide whether you want to sell your software. Although it is possible to make money by selling software, it is quite unlikely that people will buy your first software that usually has few features and nothing special. Also, if a gratis program doesn't work, people who downloaded it will just be disappointed; if they paid for it, however, they'll demand their money back, causing more problems for both you and the users. So consider making your first few programs available for free. Decide how you want to publish your game. Every method has some advantages and disadvantages, so you have to decide yourself. Publishing it on a website: If you have a website, you can upload your game on it. Make sure to give the visitors instructions on how to install not only the software, but also the dependencies. The disadvantage of this method is that the user has install the dependencies manually, which may be too hard for some people who just want to play the game, and a quite boring task. Making a package for a package manager: there are different package managers, like apt, yum or homebrew. They all have different, specific package formats. Refer to the reference for the respective format. The good thing about package manager packages is that they will automatically install all dependencies if you configure them correctly. So the user only has to install your package and can then play the game. The problem is that there are many different package managers on different platforms, so you will have to put some work into providing packages for all the most common ones. Direct attention to your program. Consider uploading your program to a major package repository, like the ones Ubuntu and Debian maintain. This will allow users to install it very easily. Also, post in appropriate forums, like the projects section of GameDev or a part of tigSource. But don't be disappointed if your first games don't become famous. Move on, if you have some idea that many people like and code it, your game can become well-known.",
  "tyn_model":[
    "python",
    "keyboard",
    "bat",
    "blender",
    "bats",
    "sprite",
    "software",
    "media",
    "platformer controller",
    "program",
    "ice",
    "tiles",
    "task",
    "programming language",
    "programming languages",
    "random",
    "menu",
    "tile",
    "penguin",
    "3d editing",
    "camera",
    "lighting",
    "ball",
    "libraries",
    "package manager",
    "package managers",
    "java",
    "visual basic",
    "text editor",
    "random number function",
    "random function",
    "random library",
    "number",
    "random\n\ndef",
    "python 3",
    "game engine library",
    "cocos",
    "modules",
    "sprites",
    "image",
    "math",
    "ice tiles",
    "scrolling manager",
    "gravity",
    "ice blocks",
    "python code",
    "label",
    "tilefile.write('</column>\\n'",
    ")\n        ",
    "tilefile.write('</rectmap>\\n<",
    "cube",
    "\u2192 transform",
    "\u2192 origin",
    "3d library",
    "\u2192 user",
    "directx x format",
    "\u2192 export",
    "\u2192 directx",
    "mouse",
    "\u2014 inside",
    "\u2014 so",
    "lights",
    "notifier",
    ", self.notifier",
    "collision traverser",
    "\u2014 if",
    "pos",
    "scale",
    "gpl without linking exception: such a license",
    "homebrew"
  ],
  "tyn_section":[

  ]
}